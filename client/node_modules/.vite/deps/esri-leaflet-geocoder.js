import {
  require_leaflet_src
} from "./chunk-IDYC6UQE.js";
import {
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/esri-leaflet-geocoder/package.json
var version = "2.3.3";

// node_modules/esri-leaflet-geocoder/src/Tasks/Geocode.js
var import_leaflet16 = __toESM(require_leaflet_src());

// node_modules/esri-leaflet/src/Support.js
var cors = window.XMLHttpRequest && "withCredentials" in new window.XMLHttpRequest();
var pointerEvents = document.documentElement.style.pointerEvents === "";
var Support = {
  cors,
  pointerEvents
};

// node_modules/esri-leaflet/src/Options.js
var options = {
  attributionWidthOffset: 55
};

// node_modules/esri-leaflet/src/Util.js
var import_leaflet2 = __toESM(require_leaflet_src());

// node_modules/esri-leaflet/src/Request.js
var import_leaflet = __toESM(require_leaflet_src());
var callbacks = 0;
function serialize(params) {
  var data = "";
  params.f = params.f || "json";
  for (var key in params) {
    if (params.hasOwnProperty(key)) {
      var param = params[key];
      var type = Object.prototype.toString.call(param);
      var value;
      if (data.length) {
        data += "&";
      }
      if (type === "[object Array]") {
        value = Object.prototype.toString.call(param[0]) === "[object Object]" ? JSON.stringify(param) : param.join(",");
      } else if (type === "[object Object]") {
        value = JSON.stringify(param);
      } else if (type === "[object Date]") {
        value = param.valueOf();
      } else {
        value = param;
      }
      data += encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }
  }
  return data;
}
function createRequest(callback, context) {
  var httpRequest = new window.XMLHttpRequest();
  httpRequest.onerror = function(e) {
    httpRequest.onreadystatechange = import_leaflet.Util.falseFn;
    callback.call(context, {
      error: {
        code: 500,
        message: "XMLHttpRequest error"
      }
    }, null);
  };
  httpRequest.onreadystatechange = function() {
    var response;
    var error;
    if (httpRequest.readyState === 4) {
      try {
        response = JSON.parse(httpRequest.responseText);
      } catch (e) {
        response = null;
        error = {
          code: 500,
          message: "Could not parse response as JSON. This could also be caused by a CORS or XMLHttpRequest error."
        };
      }
      if (!error && response.error) {
        error = response.error;
        response = null;
      }
      httpRequest.onerror = import_leaflet.Util.falseFn;
      callback.call(context, error, response);
    }
  };
  httpRequest.ontimeout = function() {
    this.onerror();
  };
  return httpRequest;
}
function xmlHttpPost(url, params, callback, context) {
  var httpRequest = createRequest(callback, context);
  httpRequest.open("POST", url);
  if (typeof context !== "undefined" && context !== null) {
    if (typeof context.options !== "undefined") {
      httpRequest.timeout = context.options.timeout;
    }
  }
  httpRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
  httpRequest.send(serialize(params));
  return httpRequest;
}
function xmlHttpGet(url, params, callback, context) {
  var httpRequest = createRequest(callback, context);
  httpRequest.open("GET", url + "?" + serialize(params), true);
  if (typeof context !== "undefined" && context !== null) {
    if (typeof context.options !== "undefined") {
      httpRequest.timeout = context.options.timeout;
      if (context.options.withCredentials) {
        httpRequest.withCredentials = true;
      }
    }
  }
  httpRequest.send(null);
  return httpRequest;
}
function request(url, params, callback, context) {
  var paramString = serialize(params);
  var httpRequest = createRequest(callback, context);
  var requestLength = (url + "?" + paramString).length;
  if (requestLength <= 2e3 && Support.cors) {
    httpRequest.open("GET", url + "?" + paramString);
  } else if (requestLength > 2e3 && Support.cors) {
    httpRequest.open("POST", url);
    httpRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
  }
  if (typeof context !== "undefined" && context !== null) {
    if (typeof context.options !== "undefined") {
      httpRequest.timeout = context.options.timeout;
      if (context.options.withCredentials) {
        httpRequest.withCredentials = true;
      }
    }
  }
  if (requestLength <= 2e3 && Support.cors) {
    httpRequest.send(null);
  } else if (requestLength > 2e3 && Support.cors) {
    httpRequest.send(paramString);
  } else if (requestLength <= 2e3 && !Support.cors) {
    return jsonp(url, params, callback, context);
  } else {
    warn("a request to " + url + " was longer then 2000 characters and this browser cannot make a cross-domain post request. Please use a proxy http://esri.github.io/esri-leaflet/api-reference/request.html");
    return;
  }
  return httpRequest;
}
function jsonp(url, params, callback, context) {
  window._EsriLeafletCallbacks = window._EsriLeafletCallbacks || {};
  var callbackId = "c" + callbacks;
  params.callback = "window._EsriLeafletCallbacks." + callbackId;
  window._EsriLeafletCallbacks[callbackId] = function(response) {
    if (window._EsriLeafletCallbacks[callbackId] !== true) {
      var error;
      var responseType = Object.prototype.toString.call(response);
      if (!(responseType === "[object Object]" || responseType === "[object Array]")) {
        error = {
          error: {
            code: 500,
            message: "Expected array or object as JSONP response"
          }
        };
        response = null;
      }
      if (!error && response.error) {
        error = response;
        response = null;
      }
      callback.call(context, error, response);
      window._EsriLeafletCallbacks[callbackId] = true;
    }
  };
  var script = import_leaflet.DomUtil.create("script", null, document.body);
  script.type = "text/javascript";
  script.src = url + "?" + serialize(params);
  script.id = callbackId;
  script.onerror = function(error) {
    if (error && window._EsriLeafletCallbacks[callbackId] !== true) {
      var err = {
        error: {
          code: 500,
          message: "An unknown error occurred"
        }
      };
      callback.call(context, err);
      window._EsriLeafletCallbacks[callbackId] = true;
    }
  };
  import_leaflet.DomUtil.addClass(script, "esri-leaflet-jsonp");
  callbacks++;
  return {
    id: callbackId,
    url: script.src,
    abort: function() {
      window._EsriLeafletCallbacks._callback[callbackId]({
        code: 0,
        message: "Request aborted."
      });
    }
  };
}
var get = Support.cors ? xmlHttpGet : jsonp;
get.CORS = xmlHttpGet;
get.JSONP = jsonp;
function warn() {
  if (console && console.warn) {
    console.warn.apply(console, arguments);
  }
}
var Request = {
  request,
  get,
  post: xmlHttpPost
};
var Request_default = Request;

// node_modules/@terraformer/arcgis/dist/t-arcgis.esm.js
var edgeIntersectsEdge = function edgeIntersectsEdge2(a1, a2, b1, b2) {
  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);
  if (uB !== 0) {
    var ua = uaT / uB;
    var ub = ubT / uB;
    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return true;
    }
  }
  return false;
};
var coordinatesContainPoint = function coordinatesContainPoint2(coordinates, point2) {
  var contains = false;
  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {
    if ((coordinates[i][1] <= point2[1] && point2[1] < coordinates[j][1] || coordinates[j][1] <= point2[1] && point2[1] < coordinates[i][1]) && point2[0] < (coordinates[j][0] - coordinates[i][0]) * (point2[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {
      contains = !contains;
    }
  }
  return contains;
};
var pointsEqual = function pointsEqual2(a, b) {
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
};
var arrayIntersectsArray = function arrayIntersectsArray2(a, b) {
  for (var i = 0; i < a.length - 1; i++) {
    for (var j = 0; j < b.length - 1; j++) {
      if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {
        return true;
      }
    }
  }
  return false;
};
var closeRing = function closeRing2(coordinates) {
  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {
    coordinates.push(coordinates[0]);
  }
  return coordinates;
};
var ringIsClockwise = function ringIsClockwise2(ringToTest) {
  var total = 0;
  var i = 0;
  var rLength = ringToTest.length;
  var pt1 = ringToTest[i];
  var pt2;
  for (i; i < rLength - 1; i++) {
    pt2 = ringToTest[i + 1];
    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
    pt1 = pt2;
  }
  return total >= 0;
};
var shallowClone = function shallowClone2(obj) {
  var target = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      target[i] = obj[i];
    }
  }
  return target;
};
var coordinatesContainCoordinates = function coordinatesContainCoordinates2(outer, inner) {
  var intersects = arrayIntersectsArray(outer, inner);
  var contains = coordinatesContainPoint(outer, inner[0]);
  if (!intersects && contains) {
    return true;
  }
  return false;
};
var convertRingsToGeoJSON = function convertRingsToGeoJSON2(rings) {
  var outerRings = [];
  var holes = [];
  var x;
  var outerRing;
  var hole;
  for (var r = 0; r < rings.length; r++) {
    var ring = closeRing(rings[r].slice(0));
    if (ring.length < 4) {
      continue;
    }
    if (ringIsClockwise(ring)) {
      var polygon = [ring.slice().reverse()];
      outerRings.push(polygon);
    } else {
      holes.push(ring.slice().reverse());
    }
  }
  var uncontainedHoles = [];
  while (holes.length) {
    hole = holes.pop();
    var contained = false;
    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];
      if (coordinatesContainCoordinates(outerRing, hole)) {
        outerRings[x].push(hole);
        contained = true;
        break;
      }
    }
    if (!contained) {
      uncontainedHoles.push(hole);
    }
  }
  while (uncontainedHoles.length) {
    hole = uncontainedHoles.pop();
    var intersects = false;
    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];
      if (arrayIntersectsArray(outerRing, hole)) {
        outerRings[x].push(hole);
        intersects = true;
        break;
      }
    }
    if (!intersects) {
      outerRings.push([hole.reverse()]);
    }
  }
  if (outerRings.length === 1) {
    return {
      type: "Polygon",
      coordinates: outerRings[0]
    };
  } else {
    return {
      type: "MultiPolygon",
      coordinates: outerRings
    };
  }
};
var getId = function getId2(attributes, idAttribute) {
  var keys = idAttribute ? [idAttribute, "OBJECTID", "FID"] : ["OBJECTID", "FID"];
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key in attributes && (typeof attributes[key] === "string" || typeof attributes[key] === "number")) {
      return attributes[key];
    }
  }
  throw Error("No valid id attribute found");
};
var arcgisToGeoJSON = function arcgisToGeoJSON2(arcgis, idAttribute) {
  var geojson = {};
  if (arcgis.features) {
    geojson.type = "FeatureCollection";
    geojson.features = [];
    for (var i = 0; i < arcgis.features.length; i++) {
      geojson.features.push(arcgisToGeoJSON2(arcgis.features[i], idAttribute));
    }
  }
  if (typeof arcgis.x === "number" && typeof arcgis.y === "number") {
    geojson.type = "Point";
    geojson.coordinates = [arcgis.x, arcgis.y];
    if (typeof arcgis.z === "number") {
      geojson.coordinates.push(arcgis.z);
    }
  }
  if (arcgis.points) {
    geojson.type = "MultiPoint";
    geojson.coordinates = arcgis.points.slice(0);
  }
  if (arcgis.paths) {
    if (arcgis.paths.length === 1) {
      geojson.type = "LineString";
      geojson.coordinates = arcgis.paths[0].slice(0);
    } else {
      geojson.type = "MultiLineString";
      geojson.coordinates = arcgis.paths.slice(0);
    }
  }
  if (arcgis.rings) {
    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));
  }
  if (typeof arcgis.xmin === "number" && typeof arcgis.ymin === "number" && typeof arcgis.xmax === "number" && typeof arcgis.ymax === "number") {
    geojson.type = "Polygon";
    geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];
  }
  if (arcgis.geometry || arcgis.attributes) {
    geojson.type = "Feature";
    geojson.geometry = arcgis.geometry ? arcgisToGeoJSON2(arcgis.geometry) : null;
    geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;
    if (arcgis.attributes) {
      try {
        geojson.id = getId(arcgis.attributes, idAttribute);
      } catch (err) {
      }
    }
  }
  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {
    geojson.geometry = null;
  }
  if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {
    console.warn("Object converted in non-standard crs - " + JSON.stringify(arcgis.spatialReference));
  }
  return geojson;
};
var orientRings = function orientRings2(poly) {
  var output = [];
  var polygon = poly.slice(0);
  var outerRing = closeRing(polygon.shift().slice(0));
  if (outerRing.length >= 4) {
    if (!ringIsClockwise(outerRing)) {
      outerRing.reverse();
    }
    output.push(outerRing);
    for (var i = 0; i < polygon.length; i++) {
      var hole = closeRing(polygon[i].slice(0));
      if (hole.length >= 4) {
        if (ringIsClockwise(hole)) {
          hole.reverse();
        }
        output.push(hole);
      }
    }
  }
  return output;
};
var flattenMultiPolygonRings = function flattenMultiPolygonRings2(rings) {
  var output = [];
  for (var i = 0; i < rings.length; i++) {
    var polygon = orientRings(rings[i]);
    for (var x = polygon.length - 1; x >= 0; x--) {
      var ring = polygon[x].slice(0);
      output.push(ring);
    }
  }
  return output;
};
var geojsonToArcGIS = function geojsonToArcGIS2(geojson, idAttribute) {
  idAttribute = idAttribute || "OBJECTID";
  var spatialReference = {
    wkid: 4326
  };
  var result = {};
  var i;
  switch (geojson.type) {
    case "Point":
      result.x = geojson.coordinates[0];
      result.y = geojson.coordinates[1];
      if (geojson.coordinates[2] != null) {
        result.z = geojson.coordinates[2];
      }
      result.spatialReference = spatialReference;
      break;
    case "MultiPoint":
      result.points = geojson.coordinates.slice(0);
      if (geojson.coordinates[0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "LineString":
      result.paths = [geojson.coordinates.slice(0)];
      if (geojson.coordinates[0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "MultiLineString":
      result.paths = geojson.coordinates.slice(0);
      if (geojson.coordinates[0][0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "Polygon":
      result.rings = orientRings(geojson.coordinates.slice(0));
      if (geojson.coordinates[0][0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "MultiPolygon":
      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));
      if (geojson.coordinates[0][0][0][2] != null) {
        result.hasZ = true;
      }
      result.spatialReference = spatialReference;
      break;
    case "Feature":
      if (geojson.geometry) {
        result.geometry = geojsonToArcGIS2(geojson.geometry, idAttribute);
      }
      result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};
      if (geojson.id) {
        result.attributes[idAttribute] = geojson.id;
      }
      break;
    case "FeatureCollection":
      result = [];
      for (i = 0; i < geojson.features.length; i++) {
        result.push(geojsonToArcGIS2(geojson.features[i], idAttribute));
      }
      break;
    case "GeometryCollection":
      result = [];
      for (i = 0; i < geojson.geometries.length; i++) {
        result.push(geojsonToArcGIS2(geojson.geometries[i], idAttribute));
      }
      break;
  }
  return result;
};

// node_modules/esri-leaflet/src/Util.js
var BASE_LEAFLET_ATTRIBUTION_STRING = '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>';
var POWERED_BY_ESRI_ATTRIBUTION_STRING = 'Powered by <a href="https://www.esri.com">Esri</a>';
function geojsonToArcGIS3(geojson, idAttr) {
  return geojsonToArcGIS(geojson, idAttr);
}
function arcgisToGeoJSON3(arcgis, idAttr) {
  return arcgisToGeoJSON(arcgis, idAttr);
}
function extentToBounds(extent) {
  if (extent.xmin !== "NaN" && extent.ymin !== "NaN" && extent.xmax !== "NaN" && extent.ymax !== "NaN") {
    var sw = (0, import_leaflet2.latLng)(extent.ymin, extent.xmin);
    var ne = (0, import_leaflet2.latLng)(extent.ymax, extent.xmax);
    return (0, import_leaflet2.latLngBounds)(sw, ne);
  } else {
    return null;
  }
}
function boundsToExtent(bounds2) {
  bounds2 = (0, import_leaflet2.latLngBounds)(bounds2);
  return {
    "xmin": bounds2.getSouthWest().lng,
    "ymin": bounds2.getSouthWest().lat,
    "xmax": bounds2.getNorthEast().lng,
    "ymax": bounds2.getNorthEast().lat,
    "spatialReference": {
      "wkid": 4326
    }
  };
}
var knownFieldNames = /^(OBJECTID|FID|OID|ID)$/i;
function _findIdAttributeFromResponse(response) {
  var result;
  if (response.objectIdFieldName) {
    result = response.objectIdFieldName;
  } else if (response.fields) {
    for (var j = 0; j <= response.fields.length - 1; j++) {
      if (response.fields[j].type === "esriFieldTypeOID") {
        result = response.fields[j].name;
        break;
      }
    }
    if (!result) {
      for (j = 0; j <= response.fields.length - 1; j++) {
        if (response.fields[j].name.match(knownFieldNames)) {
          result = response.fields[j].name;
          break;
        }
      }
    }
  }
  return result;
}
function _findIdAttributeFromFeature(feature) {
  for (var key in feature.attributes) {
    if (key.match(knownFieldNames)) {
      return key;
    }
  }
}
function responseToFeatureCollection(response, idAttribute) {
  var objectIdField;
  var features = response.features || response.results;
  var count = features && features.length;
  if (idAttribute) {
    objectIdField = idAttribute;
  } else {
    objectIdField = _findIdAttributeFromResponse(response);
  }
  var featureCollection = {
    type: "FeatureCollection",
    features: []
  };
  if (count) {
    for (var i = features.length - 1; i >= 0; i--) {
      var feature = arcgisToGeoJSON3(features[i], objectIdField || _findIdAttributeFromFeature(features[i]));
      featureCollection.features.push(feature);
    }
  }
  return featureCollection;
}
function cleanUrl(url) {
  url = import_leaflet2.Util.trim(url);
  if (url[url.length - 1] !== "/") {
    url += "/";
  }
  return url;
}
function getUrlParams(options2) {
  if (options2.url.indexOf("?") !== -1) {
    options2.requestParams = options2.requestParams || {};
    var queryString = options2.url.substring(options2.url.indexOf("?") + 1);
    options2.url = options2.url.split("?")[0];
    options2.requestParams = JSON.parse('{"' + decodeURI(queryString).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"') + '"}');
  }
  options2.url = cleanUrl(options2.url.split("?")[0]);
  return options2;
}
function isArcgisOnline(url) {
  return /^(?!.*utility\.arcgis\.com).*\.arcgis\.com.*FeatureServer/i.test(url);
}
function geojsonTypeToArcGIS(geoJsonType) {
  var arcgisGeometryType;
  switch (geoJsonType) {
    case "Point":
      arcgisGeometryType = "esriGeometryPoint";
      break;
    case "MultiPoint":
      arcgisGeometryType = "esriGeometryMultipoint";
      break;
    case "LineString":
      arcgisGeometryType = "esriGeometryPolyline";
      break;
    case "MultiLineString":
      arcgisGeometryType = "esriGeometryPolyline";
      break;
    case "Polygon":
      arcgisGeometryType = "esriGeometryPolygon";
      break;
    case "MultiPolygon":
      arcgisGeometryType = "esriGeometryPolygon";
      break;
  }
  return arcgisGeometryType;
}
function calcAttributionWidth(map) {
  return map.getSize().x - options.attributionWidthOffset + "px";
}
function setEsriAttribution(map) {
  if (!map.attributionControl) {
    return;
  }
  if (!map.attributionControl._esriAttributionLayerCount) {
    map.attributionControl._esriAttributionLayerCount = 0;
  }
  if (map.attributionControl._esriAttributionLayerCount === 0) {
    if (!map.attributionControl._esriAttributionAddedOnce) {
      var hoverAttributionStyle = document.createElement("style");
      hoverAttributionStyle.type = "text/css";
      hoverAttributionStyle.innerHTML = ".esri-truncated-attribution:hover {white-space: normal;}";
      document.getElementsByTagName("head")[0].appendChild(hoverAttributionStyle);
      var attributionStyle = document.createElement("style");
      attributionStyle.type = "text/css";
      attributionStyle.innerHTML = ".esri-truncated-attribution {vertical-align: -3px;white-space: nowrap;overflow: hidden;text-overflow: ellipsis;display: inline-block;transition: 0s white-space;transition-delay: 1s;max-width: " + calcAttributionWidth(map) + ";}";
      document.getElementsByTagName("head")[0].appendChild(attributionStyle);
      map.on("resize", function(e) {
        if (map.attributionControl) {
          map.attributionControl._container.style.maxWidth = calcAttributionWidth(e.target);
        }
      });
      map.attributionControl._esriAttributionAddedOnce = true;
    }
    map.attributionControl.setPrefix(BASE_LEAFLET_ATTRIBUTION_STRING + " | " + POWERED_BY_ESRI_ATTRIBUTION_STRING);
    import_leaflet2.DomUtil.addClass(map.attributionControl._container, "esri-truncated-attribution:hover");
    import_leaflet2.DomUtil.addClass(map.attributionControl._container, "esri-truncated-attribution");
  }
  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount + 1;
}
function removeEsriAttribution(map) {
  if (!map.attributionControl) {
    return;
  }
  if (map.attributionControl._esriAttributionLayerCount && map.attributionControl._esriAttributionLayerCount === 1) {
    map.attributionControl.setPrefix(BASE_LEAFLET_ATTRIBUTION_STRING);
    import_leaflet2.DomUtil.removeClass(map.attributionControl._container, "esri-truncated-attribution:hover");
    import_leaflet2.DomUtil.removeClass(map.attributionControl._container, "esri-truncated-attribution");
  }
  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount - 1;
}
function _setGeometry(geometry) {
  var params = {
    geometry: null,
    geometryType: null
  };
  if (geometry instanceof import_leaflet2.LatLngBounds) {
    params.geometry = boundsToExtent(geometry);
    params.geometryType = "esriGeometryEnvelope";
    return params;
  }
  if (geometry.getLatLng) {
    geometry = geometry.getLatLng();
  }
  if (geometry instanceof import_leaflet2.LatLng) {
    geometry = {
      type: "Point",
      coordinates: [geometry.lng, geometry.lat]
    };
  }
  if (geometry instanceof import_leaflet2.GeoJSON) {
    geometry = geometry.getLayers()[0].feature.geometry;
    params.geometry = geojsonToArcGIS3(geometry);
    params.geometryType = geojsonTypeToArcGIS(geometry.type);
  }
  if (geometry.toGeoJSON) {
    geometry = geometry.toGeoJSON();
  }
  if (geometry.type === "Feature") {
    geometry = geometry.geometry;
  }
  if (geometry.type === "Point" || geometry.type === "LineString" || geometry.type === "Polygon" || geometry.type === "MultiPolygon") {
    params.geometry = geojsonToArcGIS3(geometry);
    params.geometryType = geojsonTypeToArcGIS(geometry.type);
    return params;
  }
  warn("invalid geometry passed to spatial query. Should be L.LatLng, L.LatLngBounds, L.Marker or a GeoJSON Point, Line, Polygon or MultiPolygon object");
  return;
}
function _getAttributionData(url, map) {
  if (Support.cors) {
    request(url, {}, import_leaflet2.Util.bind(function(error, attributions) {
      if (error) {
        return;
      }
      map._esriAttributions = [];
      for (var c = 0; c < attributions.contributors.length; c++) {
        var contributor = attributions.contributors[c];
        for (var i = 0; i < contributor.coverageAreas.length; i++) {
          var coverageArea = contributor.coverageAreas[i];
          var southWest = (0, import_leaflet2.latLng)(coverageArea.bbox[0], coverageArea.bbox[1]);
          var northEast = (0, import_leaflet2.latLng)(coverageArea.bbox[2], coverageArea.bbox[3]);
          map._esriAttributions.push({
            attribution: contributor.attribution,
            score: coverageArea.score,
            bounds: (0, import_leaflet2.latLngBounds)(southWest, northEast),
            minZoom: coverageArea.zoomMin,
            maxZoom: coverageArea.zoomMax
          });
        }
      }
      map._esriAttributions.sort(function(a, b) {
        return b.score - a.score;
      });
      var obj = { target: map };
      _updateMapAttribution(obj);
    }, this));
  }
}
function _updateMapAttribution(evt) {
  var map = evt.target;
  var oldAttributions = map._esriAttributions;
  if (!map || !map.attributionControl)
    return;
  var attributionElement = map.attributionControl._container.querySelector(".esri-dynamic-attribution");
  if (attributionElement && oldAttributions) {
    var newAttributions = "";
    var bounds2 = map.getBounds();
    var wrappedBounds = (0, import_leaflet2.latLngBounds)(
      bounds2.getSouthWest().wrap(),
      bounds2.getNorthEast().wrap()
    );
    var zoom = map.getZoom();
    for (var i = 0; i < oldAttributions.length; i++) {
      var attribution = oldAttributions[i];
      var text = attribution.attribution;
      if (!newAttributions.match(text) && attribution.bounds.intersects(wrappedBounds) && zoom >= attribution.minZoom && zoom <= attribution.maxZoom) {
        newAttributions += ", " + text;
      }
    }
    newAttributions = newAttributions.substr(2);
    attributionElement.innerHTML = newAttributions;
    attributionElement.style.maxWidth = calcAttributionWidth(map);
    map.fire("attributionupdated", {
      attribution: newAttributions
    });
  }
}
var EsriUtil = {
  warn,
  cleanUrl,
  getUrlParams,
  isArcgisOnline,
  geojsonTypeToArcGIS,
  responseToFeatureCollection,
  geojsonToArcGIS: geojsonToArcGIS3,
  arcgisToGeoJSON: arcgisToGeoJSON3,
  boundsToExtent,
  extentToBounds,
  calcAttributionWidth,
  setEsriAttribution,
  _setGeometry,
  _getAttributionData,
  _updateMapAttribution,
  _findIdAttributeFromFeature,
  _findIdAttributeFromResponse
};

// node_modules/esri-leaflet/src/Tasks/Task.js
var import_leaflet3 = __toESM(require_leaflet_src());
var Task = import_leaflet3.Class.extend({
  options: {
    proxy: false,
    useCors: cors
  },
  // Generate a method for each methodName:paramName in the setters for this task.
  generateSetter: function(param, context) {
    return import_leaflet3.Util.bind(function(value) {
      this.params[param] = value;
      return this;
    }, context);
  },
  initialize: function(endpoint) {
    if (endpoint.request && endpoint.options) {
      this._service = endpoint;
      import_leaflet3.Util.setOptions(this, endpoint.options);
    } else {
      import_leaflet3.Util.setOptions(this, endpoint);
      this.options.url = cleanUrl(endpoint.url);
    }
    this.params = import_leaflet3.Util.extend({}, this.params || {});
    if (this.setters) {
      for (var setter in this.setters) {
        var param = this.setters[setter];
        this[setter] = this.generateSetter(param, this);
      }
    }
  },
  token: function(token) {
    if (this._service) {
      this._service.authenticate(token);
    } else {
      this.params.token = token;
    }
    return this;
  },
  // ArcGIS Server Find/Identify 10.5+
  format: function(boolean) {
    this.params.returnUnformattedValues = !boolean;
    return this;
  },
  request: function(callback, context) {
    if (this.options.requestParams) {
      import_leaflet3.Util.extend(this.params, this.options.requestParams);
    }
    if (this._service) {
      return this._service.request(this.path, this.params, callback, context);
    }
    return this._request("request", this.path, this.params, callback, context);
  },
  _request: function(method, path, params, callback, context) {
    var url = this.options.proxy ? this.options.proxy + "?" + this.options.url + path : this.options.url + path;
    if ((method === "get" || method === "request") && !this.options.useCors) {
      return Request_default.get.JSONP(url, params, callback, context);
    }
    return Request_default[method](url, params, callback, context);
  }
});

// node_modules/esri-leaflet/src/Tasks/Query.js
var import_leaflet4 = __toESM(require_leaflet_src());
var Query = Task.extend({
  setters: {
    "offset": "resultOffset",
    "limit": "resultRecordCount",
    "fields": "outFields",
    "precision": "geometryPrecision",
    "featureIds": "objectIds",
    "returnGeometry": "returnGeometry",
    "returnM": "returnM",
    "transform": "datumTransformation",
    "token": "token"
  },
  path: "query",
  params: {
    returnGeometry: true,
    where: "1=1",
    outSR: 4326,
    outFields: "*"
  },
  // Returns a feature if its shape is wholly contained within the search geometry. Valid for all shape type combinations.
  within: function(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelContains";
    return this;
  },
  // Returns a feature if any spatial relationship is found. Applies to all shape type combinations.
  intersects: function(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelIntersects";
    return this;
  },
  // Returns a feature if its shape wholly contains the search geometry. Valid for all shape type combinations.
  contains: function(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelWithin";
    return this;
  },
  // Returns a feature if the intersection of the interiors of the two shapes is not empty and has a lower dimension than the maximum dimension of the two shapes. Two lines that share an endpoint in common do not cross. Valid for Line/Line, Line/Area, Multi-point/Area, and Multi-point/Line shape type combinations.
  crosses: function(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelCrosses";
    return this;
  },
  // Returns a feature if the two shapes share a common boundary. However, the intersection of the interiors of the two shapes must be empty. In the Point/Line case, the point may touch an endpoint only of the line. Applies to all combinations except Point/Point.
  touches: function(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelTouches";
    return this;
  },
  // Returns a feature if the intersection of the two shapes results in an object of the same dimension, but different from both of the shapes. Applies to Area/Area, Line/Line, and Multi-point/Multi-point shape type combinations.
  overlaps: function(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelOverlaps";
    return this;
  },
  // Returns a feature if the envelope of the two shapes intersects.
  bboxIntersects: function(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelEnvelopeIntersects";
    return this;
  },
  // if someone can help decipher the ArcObjects explanation and translate to plain speak, we should mention this method in the doc
  indexIntersects: function(geometry) {
    this._setGeometryParams(geometry);
    this.params.spatialRel = "esriSpatialRelIndexIntersects";
    return this;
  },
  // only valid for Feature Services running on ArcGIS Server 10.3+ or ArcGIS Online
  nearby: function(latlng, radius) {
    latlng = (0, import_leaflet4.latLng)(latlng);
    this.params.geometry = [latlng.lng, latlng.lat];
    this.params.geometryType = "esriGeometryPoint";
    this.params.spatialRel = "esriSpatialRelIntersects";
    this.params.units = "esriSRUnit_Meter";
    this.params.distance = radius;
    this.params.inSR = 4326;
    return this;
  },
  where: function(string) {
    this.params.where = string;
    return this;
  },
  between: function(start, end) {
    this.params.time = [start.valueOf(), end.valueOf()];
    return this;
  },
  simplify: function(map, factor) {
    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());
    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;
    return this;
  },
  orderBy: function(fieldName, order) {
    order = order || "ASC";
    this.params.orderByFields = this.params.orderByFields ? this.params.orderByFields + "," : "";
    this.params.orderByFields += [fieldName, order].join(" ");
    return this;
  },
  run: function(callback, context) {
    this._cleanParams();
    if (this.options.isModern || isArcgisOnline(this.options.url) && this.options.isModern === void 0) {
      this.params.f = "geojson";
      return this.request(function(error, response) {
        this._trapSQLerrors(error);
        callback.call(context, error, response, response);
      }, this);
    } else {
      return this.request(function(error, response) {
        this._trapSQLerrors(error);
        callback.call(context, error, response && responseToFeatureCollection(response), response);
      }, this);
    }
  },
  count: function(callback, context) {
    this._cleanParams();
    this.params.returnCountOnly = true;
    return this.request(function(error, response) {
      callback.call(this, error, response && response.count, response);
    }, context);
  },
  ids: function(callback, context) {
    this._cleanParams();
    this.params.returnIdsOnly = true;
    return this.request(function(error, response) {
      callback.call(this, error, response && response.objectIds, response);
    }, context);
  },
  // only valid for Feature Services running on ArcGIS Server 10.3+ or ArcGIS Online
  bounds: function(callback, context) {
    this._cleanParams();
    this.params.returnExtentOnly = true;
    return this.request(function(error, response) {
      if (response && response.extent && extentToBounds(response.extent)) {
        callback.call(context, error, extentToBounds(response.extent), response);
      } else {
        error = {
          message: "Invalid Bounds"
        };
        callback.call(context, error, null, response);
      }
    }, context);
  },
  distinct: function() {
    this.params.returnGeometry = false;
    this.params.returnDistinctValues = true;
    return this;
  },
  // only valid for image services
  pixelSize: function(rawPoint) {
    var castPoint = (0, import_leaflet4.point)(rawPoint);
    this.params.pixelSize = [castPoint.x, castPoint.y];
    return this;
  },
  // only valid for map services
  layer: function(layer) {
    this.path = layer + "/query";
    return this;
  },
  _trapSQLerrors: function(error) {
    if (error) {
      if (error.code === "400") {
        warn("one common syntax error in query requests is encasing string values in double quotes instead of single quotes");
      }
    }
  },
  _cleanParams: function() {
    delete this.params.returnIdsOnly;
    delete this.params.returnExtentOnly;
    delete this.params.returnCountOnly;
  },
  _setGeometryParams: function(geometry) {
    this.params.inSR = 4326;
    var converted = _setGeometry(geometry);
    this.params.geometry = converted.geometry;
    this.params.geometryType = converted.geometryType;
  }
});
function query(options2) {
  return new Query(options2);
}
var Query_default = query;

// node_modules/esri-leaflet/src/Tasks/Find.js
var Find = Task.extend({
  setters: {
    // method name > param name
    "contains": "contains",
    "text": "searchText",
    "fields": "searchFields",
    // denote an array or single string
    "spatialReference": "sr",
    "sr": "sr",
    "layers": "layers",
    "returnGeometry": "returnGeometry",
    "maxAllowableOffset": "maxAllowableOffset",
    "precision": "geometryPrecision",
    "dynamicLayers": "dynamicLayers",
    "returnZ": "returnZ",
    "returnM": "returnM",
    "gdbVersion": "gdbVersion",
    // skipped implementing this (for now) because the REST service implementation isnt consistent between operations
    // 'transform': 'datumTransformations',
    "token": "token"
  },
  path: "find",
  params: {
    sr: 4326,
    contains: true,
    returnGeometry: true,
    returnZ: true,
    returnM: false
  },
  layerDefs: function(id, where) {
    this.params.layerDefs = this.params.layerDefs ? this.params.layerDefs + ";" : "";
    this.params.layerDefs += [id, where].join(":");
    return this;
  },
  simplify: function(map, factor) {
    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());
    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;
    return this;
  },
  run: function(callback, context) {
    return this.request(function(error, response) {
      callback.call(context, error, response && responseToFeatureCollection(response), response);
    }, context);
  }
});
function find(options2) {
  return new Find(options2);
}
var Find_default = find;

// node_modules/esri-leaflet/src/Tasks/Identify.js
var Identify = Task.extend({
  path: "identify",
  between: function(start, end) {
    this.params.time = [start.valueOf(), end.valueOf()];
    return this;
  }
});

// node_modules/esri-leaflet/src/Tasks/IdentifyFeatures.js
var import_leaflet5 = __toESM(require_leaflet_src());
var IdentifyFeatures = Identify.extend({
  setters: {
    "layers": "layers",
    "precision": "geometryPrecision",
    "tolerance": "tolerance",
    // skipped implementing this (for now) because the REST service implementation isnt consistent between operations.
    // 'transform': 'datumTransformations'
    "returnGeometry": "returnGeometry"
  },
  params: {
    sr: 4326,
    layers: "all",
    tolerance: 3,
    returnGeometry: true
  },
  on: function(map) {
    var extent = boundsToExtent(map.getBounds());
    var size = map.getSize();
    this.params.imageDisplay = [size.x, size.y, 96];
    this.params.mapExtent = [extent.xmin, extent.ymin, extent.xmax, extent.ymax];
    return this;
  },
  at: function(geometry) {
    if (geometry.length === 2) {
      geometry = (0, import_leaflet5.latLng)(geometry);
    }
    this._setGeometryParams(geometry);
    return this;
  },
  layerDef: function(id, where) {
    this.params.layerDefs = this.params.layerDefs ? this.params.layerDefs + ";" : "";
    this.params.layerDefs += [id, where].join(":");
    return this;
  },
  simplify: function(map, factor) {
    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());
    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;
    return this;
  },
  run: function(callback, context) {
    return this.request(function(error, response) {
      if (error) {
        callback.call(context, error, void 0, response);
        return;
      } else {
        var featureCollection = responseToFeatureCollection(response);
        response.results = response.results.reverse();
        for (var i = 0; i < featureCollection.features.length; i++) {
          var feature = featureCollection.features[i];
          feature.layerId = response.results[i].layerId;
        }
        callback.call(context, void 0, featureCollection, response);
      }
    });
  },
  _setGeometryParams: function(geometry) {
    var converted = _setGeometry(geometry);
    this.params.geometry = converted.geometry;
    this.params.geometryType = converted.geometryType;
  }
});
function identifyFeatures(options2) {
  return new IdentifyFeatures(options2);
}
var IdentifyFeatures_default = identifyFeatures;

// node_modules/esri-leaflet/src/Tasks/IdentifyImage.js
var import_leaflet6 = __toESM(require_leaflet_src());
var IdentifyImage = Identify.extend({
  setters: {
    "setMosaicRule": "mosaicRule",
    "setRenderingRule": "renderingRule",
    "setPixelSize": "pixelSize",
    "returnCatalogItems": "returnCatalogItems",
    "returnGeometry": "returnGeometry"
  },
  params: {
    returnGeometry: false
  },
  at: function(latlng) {
    latlng = (0, import_leaflet6.latLng)(latlng);
    this.params.geometry = JSON.stringify({
      x: latlng.lng,
      y: latlng.lat,
      spatialReference: {
        wkid: 4326
      }
    });
    this.params.geometryType = "esriGeometryPoint";
    return this;
  },
  getMosaicRule: function() {
    return this.params.mosaicRule;
  },
  getRenderingRule: function() {
    return this.params.renderingRule;
  },
  getPixelSize: function() {
    return this.params.pixelSize;
  },
  run: function(callback, context) {
    return this.request(function(error, response) {
      callback.call(context, error, response && this._responseToGeoJSON(response), response);
    }, this);
  },
  // get pixel data and return as geoJSON point
  // populate catalog items (if any)
  // merging in any catalogItemVisibilities as a propery of each feature
  _responseToGeoJSON: function(response) {
    var location = response.location;
    var catalogItems = response.catalogItems;
    var catalogItemVisibilities = response.catalogItemVisibilities;
    var geoJSON = {
      "pixel": {
        "type": "Feature",
        "geometry": {
          "type": "Point",
          "coordinates": [location.x, location.y]
        },
        "crs": {
          "type": "EPSG",
          "properties": {
            "code": location.spatialReference.wkid
          }
        },
        "properties": {
          "OBJECTID": response.objectId,
          "name": response.name,
          "value": response.value
        },
        "id": response.objectId
      }
    };
    if (response.properties && response.properties.Values) {
      geoJSON.pixel.properties.values = response.properties.Values;
    }
    if (catalogItems && catalogItems.features) {
      geoJSON.catalogItems = responseToFeatureCollection(catalogItems);
      if (catalogItemVisibilities && catalogItemVisibilities.length === geoJSON.catalogItems.features.length) {
        for (var i = catalogItemVisibilities.length - 1; i >= 0; i--) {
          geoJSON.catalogItems.features[i].properties.catalogItemVisibility = catalogItemVisibilities[i];
        }
      }
    }
    return geoJSON;
  }
});
function identifyImage(params) {
  return new IdentifyImage(params);
}
var IdentifyImage_default = identifyImage;

// node_modules/esri-leaflet/src/Services/Service.js
var import_leaflet7 = __toESM(require_leaflet_src());
var Service = import_leaflet7.Evented.extend({
  options: {
    proxy: false,
    useCors: cors,
    timeout: 0
  },
  initialize: function(options2) {
    options2 = options2 || {};
    this._requestQueue = [];
    this._authenticating = false;
    import_leaflet7.Util.setOptions(this, options2);
    this.options.url = cleanUrl(this.options.url);
  },
  get: function(path, params, callback, context) {
    return this._request("get", path, params, callback, context);
  },
  post: function(path, params, callback, context) {
    return this._request("post", path, params, callback, context);
  },
  request: function(path, params, callback, context) {
    return this._request("request", path, params, callback, context);
  },
  metadata: function(callback, context) {
    return this._request("get", "", {}, callback, context);
  },
  authenticate: function(token) {
    this._authenticating = false;
    this.options.token = token;
    this._runQueue();
    return this;
  },
  getTimeout: function() {
    return this.options.timeout;
  },
  setTimeout: function(timeout) {
    this.options.timeout = timeout;
  },
  _request: function(method, path, params, callback, context) {
    this.fire("requeststart", {
      url: this.options.url + path,
      params,
      method
    }, true);
    var wrappedCallback = this._createServiceCallback(method, path, params, callback, context);
    if (this.options.token) {
      params.token = this.options.token;
    }
    if (this.options.requestParams) {
      import_leaflet7.Util.extend(params, this.options.requestParams);
    }
    if (this._authenticating) {
      this._requestQueue.push([method, path, params, callback, context]);
      return;
    } else {
      var url = this.options.proxy ? this.options.proxy + "?" + this.options.url + path : this.options.url + path;
      if ((method === "get" || method === "request") && !this.options.useCors) {
        return Request_default.get.JSONP(url, params, wrappedCallback, context);
      } else {
        return Request_default[method](url, params, wrappedCallback, context);
      }
    }
  },
  _createServiceCallback: function(method, path, params, callback, context) {
    return import_leaflet7.Util.bind(function(error, response) {
      if (error && (error.code === 499 || error.code === 498)) {
        this._authenticating = true;
        this._requestQueue.push([method, path, params, callback, context]);
        this.fire("authenticationrequired", {
          authenticate: import_leaflet7.Util.bind(this.authenticate, this)
        }, true);
        error.authenticate = import_leaflet7.Util.bind(this.authenticate, this);
      }
      callback.call(context, error, response);
      if (error) {
        this.fire("requesterror", {
          url: this.options.url + path,
          params,
          message: error.message,
          code: error.code,
          method
        }, true);
      } else {
        this.fire("requestsuccess", {
          url: this.options.url + path,
          params,
          response,
          method
        }, true);
      }
      this.fire("requestend", {
        url: this.options.url + path,
        params,
        method
      }, true);
    }, this);
  },
  _runQueue: function() {
    for (var i = this._requestQueue.length - 1; i >= 0; i--) {
      var request2 = this._requestQueue[i];
      var method = request2.shift();
      this[method].apply(this, request2);
    }
    this._requestQueue = [];
  }
});

// node_modules/esri-leaflet/src/Services/MapService.js
var MapService = Service.extend({
  identify: function() {
    return IdentifyFeatures_default(this);
  },
  find: function() {
    return Find_default(this);
  },
  query: function() {
    return Query_default(this);
  }
});
function mapService(options2) {
  return new MapService(options2);
}
var MapService_default = mapService;

// node_modules/esri-leaflet/src/Services/ImageService.js
var ImageService = Service.extend({
  query: function() {
    return Query_default(this);
  },
  identify: function() {
    return IdentifyImage_default(this);
  }
});
function imageService(options2) {
  return new ImageService(options2);
}
var ImageService_default = imageService;

// node_modules/esri-leaflet/src/Services/FeatureLayerService.js
var FeatureLayerService = Service.extend({
  options: {
    idAttribute: "OBJECTID"
  },
  query: function() {
    return Query_default(this);
  },
  addFeature: function(feature, callback, context) {
    this.addFeatures(feature, callback, context);
  },
  addFeatures: function(features, callback, context) {
    var featuresArray = features.features ? features.features : [features];
    for (var i = featuresArray.length - 1; i >= 0; i--) {
      delete featuresArray[i].id;
    }
    features = geojsonToArcGIS3(features);
    features = featuresArray.length > 1 ? features : [features];
    return this.post("addFeatures", {
      features
    }, function(error, response) {
      var result = response && response.addResults ? response.addResults.length > 1 ? response.addResults : response.addResults[0] : void 0;
      if (callback) {
        callback.call(context, error || response.addResults[0].error, result);
      }
    }, context);
  },
  updateFeature: function(feature, callback, context) {
    this.updateFeatures(feature, callback, context);
  },
  updateFeatures: function(features, callback, context) {
    var featuresArray = features.features ? features.features : [features];
    features = geojsonToArcGIS3(features, this.options.idAttribute);
    features = featuresArray.length > 1 ? features : [features];
    return this.post("updateFeatures", {
      features
    }, function(error, response) {
      var result = response && response.updateResults ? response.updateResults.length > 1 ? response.updateResults : response.updateResults[0] : void 0;
      if (callback) {
        callback.call(context, error || response.updateResults[0].error, result);
      }
    }, context);
  },
  deleteFeature: function(id, callback, context) {
    this.deleteFeatures(id, callback, context);
  },
  deleteFeatures: function(ids, callback, context) {
    return this.post("deleteFeatures", {
      objectIds: ids
    }, function(error, response) {
      var result = response && response.deleteResults ? response.deleteResults.length > 1 ? response.deleteResults : response.deleteResults[0] : void 0;
      if (callback) {
        callback.call(context, error || response.deleteResults[0].error, result);
      }
    }, context);
  }
});
function featureLayerService(options2) {
  return new FeatureLayerService(options2);
}
var FeatureLayerService_default = featureLayerService;

// node_modules/esri-leaflet/src/Layers/BasemapLayer.js
var import_leaflet8 = __toESM(require_leaflet_src());
var tileProtocol = window.location.protocol !== "https:" ? "http:" : "https:";
var BasemapLayer = import_leaflet8.TileLayer.extend({
  statics: {
    TILES: {
      Streets: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          attribution: "USGS, NOAA",
          attributionUrl: "https://static.arcgis.com/attribution/World_Street_Map"
        }
      },
      Topographic: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          attribution: "USGS, NOAA",
          attributionUrl: "https://static.arcgis.com/attribution/World_Topo_Map"
        }
      },
      Oceans: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          attribution: "USGS, NOAA",
          attributionUrl: "https://static.arcgis.com/attribution/Ocean_Basemap"
        }
      },
      OceansLabels: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      NationalGeographic: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          attribution: "National Geographic, DeLorme, HERE, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, increment P Corp."
        }
      },
      DarkGray: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          attribution: "HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors"
        }
      },
      DarkGrayLabels: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      Gray: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          attribution: "HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors"
        }
      },
      GrayLabels: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      Imagery: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          attribution: "DigitalGlobe, GeoEye, i-cubed, USDA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community",
          attributionUrl: "https://static.arcgis.com/attribution/World_Imagery"
        }
      },
      ImageryLabels: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      ImageryTransportation: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      ShadedRelief: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 13,
          subdomains: ["server", "services"],
          attribution: "USGS"
        }
      },
      ShadedReliefLabels: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places_Alternate/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 12,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      Terrain: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 13,
          subdomains: ["server", "services"],
          attribution: "USGS, NOAA"
        }
      },
      TerrainLabels: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 13,
          subdomains: ["server", "services"],
          pane: pointerEvents ? "esri-labels" : "tilePane",
          attribution: ""
        }
      },
      USATopo: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/ArcGIS/rest/services/USA_Topo_Maps/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 15,
          subdomains: ["server", "services"],
          attribution: "USGS, National Geographic Society, i-cubed"
        }
      },
      ImageryClarity: {
        urlTemplate: tileProtocol + "//clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 19,
          attribution: "Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community"
        }
      },
      Physical: {
        urlTemplate: tileProtocol + "//{s}.arcgisonline.com/arcgis/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 8,
          subdomains: ["server", "services"],
          attribution: "U.S. National Park Service"
        }
      },
      ImageryFirefly: {
        urlTemplate: tileProtocol + "//fly.maptiles.arcgis.com/arcgis/rest/services/World_Imagery_Firefly/MapServer/tile/{z}/{y}/{x}",
        options: {
          minZoom: 1,
          maxZoom: 19,
          attribution: "Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community",
          attributionUrl: "https://static.arcgis.com/attribution/World_Imagery"
        }
      }
    }
  },
  initialize: function(key, options2) {
    var config;
    if (typeof key === "object" && key.urlTemplate && key.options) {
      config = key;
    } else if (typeof key === "string" && BasemapLayer.TILES[key]) {
      config = BasemapLayer.TILES[key];
    } else {
      throw new Error('L.esri.BasemapLayer: Invalid parameter. Use one of "Streets", "Topographic", "Oceans", "OceansLabels", "NationalGeographic", "Physical", "Gray", "GrayLabels", "DarkGray", "DarkGrayLabels", "Imagery", "ImageryLabels", "ImageryTransportation", "ImageryClarity", "ImageryFirefly", ShadedRelief", "ShadedReliefLabels", "Terrain", "TerrainLabels" or "USATopo"');
    }
    var tileOptions = import_leaflet8.Util.extend(config.options, options2);
    import_leaflet8.Util.setOptions(this, tileOptions);
    if (this.options.token && config.urlTemplate.indexOf("token=") === -1) {
      config.urlTemplate += "?token=" + this.options.token;
    }
    if (this.options.proxy) {
      config.urlTemplate = this.options.proxy + "?" + config.urlTemplate;
    }
    import_leaflet8.TileLayer.prototype.initialize.call(this, config.urlTemplate, tileOptions);
  },
  onAdd: function(map) {
    setEsriAttribution(map);
    if (this.options.pane === "esri-labels") {
      this._initPane();
    }
    if (this.options.attributionUrl) {
      _getAttributionData((this.options.proxy ? this.options.proxy + "?" : "") + this.options.attributionUrl, map);
    }
    map.on("moveend", _updateMapAttribution);
    import_leaflet8.TileLayer.prototype.onAdd.call(this, map);
  },
  onRemove: function(map) {
    removeEsriAttribution(map);
    map.off("moveend", _updateMapAttribution);
    import_leaflet8.TileLayer.prototype.onRemove.call(this, map);
  },
  _initPane: function() {
    if (!this._map.getPane(this.options.pane)) {
      var pane = this._map.createPane(this.options.pane);
      pane.style.pointerEvents = "none";
      pane.style.zIndex = 500;
    }
  },
  getAttribution: function() {
    if (this.options.attribution) {
      var attribution = '<span class="esri-dynamic-attribution">' + this.options.attribution + "</span>";
    }
    return attribution;
  }
});

// node_modules/esri-leaflet/src/Layers/TiledMapLayer.js
var import_leaflet9 = __toESM(require_leaflet_src());
var TiledMapLayer = import_leaflet9.TileLayer.extend({
  options: {
    zoomOffsetAllowance: 0.1,
    errorTileUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAA1BMVEUzNDVszlHHAAAAAXRSTlMAQObYZgAAAAlwSFlzAAAAAAAAAAAB6mUWpAAAADZJREFUeJztwQEBAAAAgiD/r25IQAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7waBAAABw08RwAAAAABJRU5ErkJggg=="
  },
  statics: {
    MercatorZoomLevels: {
      "0": 156543.033928,
      "1": 78271.5169639999,
      "2": 39135.7584820001,
      "3": 19567.8792409999,
      "4": 9783.93962049996,
      "5": 4891.96981024998,
      "6": 2445.98490512499,
      "7": 1222.99245256249,
      "8": 611.49622628138,
      "9": 305.748113140558,
      "10": 152.874056570411,
      "11": 76.4370282850732,
      "12": 38.2185141425366,
      "13": 19.1092570712683,
      "14": 9.55462853563415,
      "15": 4.77731426794937,
      "16": 2.38865713397468,
      "17": 1.19432856685505,
      "18": 0.597164283559817,
      "19": 0.298582141647617,
      "20": 0.14929107082381,
      "21": 0.07464553541191,
      "22": 0.0373227677059525,
      "23": 0.0186613838529763
    }
  },
  initialize: function(options2) {
    options2 = import_leaflet9.Util.setOptions(this, options2);
    options2 = getUrlParams(options2);
    this.tileUrl = (options2.proxy ? options2.proxy + "?" : "") + options2.url + "tile/{z}/{y}/{x}" + (options2.requestParams && Object.keys(options2.requestParams).length > 0 ? import_leaflet9.Util.getParamString(options2.requestParams) : "");
    if (options2.url.indexOf("{s}") !== -1 && options2.subdomains) {
      options2.url = options2.url.replace("{s}", options2.subdomains[0]);
    }
    this.service = MapService_default(options2);
    this.service.addEventParent(this);
    var arcgisonline = new RegExp(/tiles.arcgis(online)?\.com/g);
    if (arcgisonline.test(options2.url)) {
      this.tileUrl = this.tileUrl.replace("://tiles", "://tiles{s}");
      options2.subdomains = ["1", "2", "3", "4"];
    }
    if (this.options.token) {
      this.tileUrl += "?token=" + this.options.token;
    }
    import_leaflet9.TileLayer.prototype.initialize.call(this, this.tileUrl, options2);
  },
  getTileUrl: function(tilePoint) {
    var zoom = this._getZoomForUrl();
    return import_leaflet9.Util.template(this.tileUrl, import_leaflet9.Util.extend({
      s: this._getSubdomain(tilePoint),
      x: tilePoint.x,
      y: tilePoint.y,
      // try lod map first, then just default to zoom level
      z: this._lodMap && this._lodMap[zoom] ? this._lodMap[zoom] : zoom
    }, this.options));
  },
  createTile: function(coords, done) {
    var tile = document.createElement("img");
    import_leaflet9.DomEvent.on(tile, "load", import_leaflet9.Util.bind(this._tileOnLoad, this, done, tile));
    import_leaflet9.DomEvent.on(tile, "error", import_leaflet9.Util.bind(this._tileOnError, this, done, tile));
    if (this.options.crossOrigin) {
      tile.crossOrigin = "";
    }
    tile.alt = "";
    if (!this._lodMap || this._lodMap && this._lodMap[this._getZoomForUrl()]) {
      tile.src = this.getTileUrl(coords);
    } else {
      this.once("lodmap", function() {
        tile.src = this.getTileUrl(coords);
      }, this);
    }
    return tile;
  },
  onAdd: function(map) {
    setEsriAttribution(map);
    if (!this._lodMap) {
      this.metadata(function(error, metadata) {
        if (!error && metadata.spatialReference) {
          var sr = metadata.spatialReference.latestWkid || metadata.spatialReference.wkid;
          if (!this.options.attribution && map.attributionControl && metadata.copyrightText) {
            this.options.attribution = metadata.copyrightText;
            map.attributionControl.addAttribution(this.getAttribution());
          }
          if (map.options.crs === import_leaflet9.CRS.EPSG3857 && (sr === 102100 || sr === 3857)) {
            this._lodMap = {};
            var arcgisLODs = metadata.tileInfo.lods;
            var correctResolutions = TiledMapLayer.MercatorZoomLevels;
            for (var i = 0; i < arcgisLODs.length; i++) {
              var arcgisLOD = arcgisLODs[i];
              for (var ci in correctResolutions) {
                var correctRes = correctResolutions[ci];
                if (this._withinPercentage(arcgisLOD.resolution, correctRes, this.options.zoomOffsetAllowance)) {
                  this._lodMap[ci] = arcgisLOD.level;
                  break;
                }
              }
            }
            this.fire("lodmap");
          } else if (map.options.crs && map.options.crs.code && map.options.crs.code.indexOf(sr) > -1) {
          } else {
            warn("L.esri.TiledMapLayer is using a non-mercator spatial reference. Support may be available through Proj4Leaflet http://esri.github.io/esri-leaflet/examples/non-mercator-projection.html");
          }
        }
      }, this);
    }
    import_leaflet9.TileLayer.prototype.onAdd.call(this, map);
  },
  onRemove: function(map) {
    removeEsriAttribution(map);
  },
  metadata: function(callback, context) {
    this.service.metadata(callback, context);
    return this;
  },
  identify: function() {
    return this.service.identify();
  },
  find: function() {
    return this.service.find();
  },
  query: function() {
    return this.service.query();
  },
  authenticate: function(token) {
    var tokenQs = "?token=" + token;
    this.tileUrl = this.options.token ? this.tileUrl.replace(/\?token=(.+)/g, tokenQs) : this.tileUrl + tokenQs;
    this.options.token = token;
    this.service.authenticate(token);
    return this;
  },
  _withinPercentage: function(a, b, percentage) {
    var diff = Math.abs(a / b - 1);
    return diff < percentage;
  }
});

// node_modules/esri-leaflet/src/Layers/RasterLayer.js
var import_leaflet10 = __toESM(require_leaflet_src());
var Overlay = import_leaflet10.ImageOverlay.extend({
  onAdd: function(map) {
    this._topLeft = map.getPixelBounds().min;
    import_leaflet10.ImageOverlay.prototype.onAdd.call(this, map);
  },
  _reset: function() {
    if (this._map.options.crs === import_leaflet10.CRS.EPSG3857) {
      import_leaflet10.ImageOverlay.prototype._reset.call(this);
    } else {
      import_leaflet10.DomUtil.setPosition(this._image, this._topLeft.subtract(this._map.getPixelOrigin()));
    }
  }
});
var RasterLayer = import_leaflet10.Layer.extend({
  options: {
    opacity: 1,
    position: "front",
    f: "image",
    useCors: cors,
    attribution: null,
    interactive: false,
    alt: ""
  },
  onAdd: function(map) {
    setEsriAttribution(map);
    if (this.options.zIndex) {
      this.options.position = null;
    }
    this._update = import_leaflet10.Util.throttle(this._update, this.options.updateInterval, this);
    map.on("moveend", this._update, this);
    if (this._currentImage && this._currentImage._bounds.equals(this._map.getBounds())) {
      map.addLayer(this._currentImage);
    } else if (this._currentImage) {
      this._map.removeLayer(this._currentImage);
      this._currentImage = null;
    }
    this._update();
    if (this._popup) {
      this._map.on("click", this._getPopupData, this);
      this._map.on("dblclick", this._resetPopupState, this);
    }
    this.metadata(function(err, metadata) {
      if (!err && !this.options.attribution && map.attributionControl && metadata.copyrightText) {
        this.options.attribution = metadata.copyrightText;
        map.attributionControl.addAttribution(this.getAttribution());
      }
    }, this);
  },
  onRemove: function(map) {
    removeEsriAttribution(map);
    if (this._currentImage) {
      this._map.removeLayer(this._currentImage);
    }
    if (this._popup) {
      this._map.off("click", this._getPopupData, this);
      this._map.off("dblclick", this._resetPopupState, this);
    }
    this._map.off("moveend", this._update, this);
  },
  bindPopup: function(fn, popupOptions) {
    this._shouldRenderPopup = false;
    this._lastClick = false;
    this._popup = (0, import_leaflet10.popup)(popupOptions);
    this._popupFunction = fn;
    if (this._map) {
      this._map.on("click", this._getPopupData, this);
      this._map.on("dblclick", this._resetPopupState, this);
    }
    return this;
  },
  unbindPopup: function() {
    if (this._map) {
      this._map.closePopup(this._popup);
      this._map.off("click", this._getPopupData, this);
      this._map.off("dblclick", this._resetPopupState, this);
    }
    this._popup = false;
    return this;
  },
  bringToFront: function() {
    this.options.position = "front";
    if (this._currentImage) {
      this._currentImage.bringToFront();
      this._setAutoZIndex(Math.max);
    }
    return this;
  },
  bringToBack: function() {
    this.options.position = "back";
    if (this._currentImage) {
      this._currentImage.bringToBack();
      this._setAutoZIndex(Math.min);
    }
    return this;
  },
  setZIndex: function(value) {
    this.options.zIndex = value;
    if (this._currentImage) {
      this._currentImage.setZIndex(value);
    }
    return this;
  },
  _setAutoZIndex: function(compare) {
    if (!this._currentImage) {
      return;
    }
    var layers = this._currentImage.getPane().children;
    var edgeZIndex = -compare(-Infinity, Infinity);
    for (var i = 0, len = layers.length, zIndex; i < len; i++) {
      zIndex = layers[i].style.zIndex;
      if (layers[i] !== this._currentImage._image && zIndex) {
        edgeZIndex = compare(edgeZIndex, +zIndex);
      }
    }
    if (isFinite(edgeZIndex)) {
      this.options.zIndex = edgeZIndex + compare(-1, 1);
      this.setZIndex(this.options.zIndex);
    }
  },
  getAttribution: function() {
    return this.options.attribution;
  },
  getOpacity: function() {
    return this.options.opacity;
  },
  setOpacity: function(opacity) {
    this.options.opacity = opacity;
    if (this._currentImage) {
      this._currentImage.setOpacity(opacity);
    }
    return this;
  },
  getTimeRange: function() {
    return [this.options.from, this.options.to];
  },
  setTimeRange: function(from, to) {
    this.options.from = from;
    this.options.to = to;
    this._update();
    return this;
  },
  metadata: function(callback, context) {
    this.service.metadata(callback, context);
    return this;
  },
  authenticate: function(token) {
    this.service.authenticate(token);
    return this;
  },
  redraw: function() {
    this._update();
  },
  _renderImage: function(url, bounds2, contentType) {
    if (this._map) {
      if (contentType) {
        url = "data:" + contentType + ";base64," + url;
      }
      if (!url)
        return;
      var image = new Overlay(url, bounds2, {
        opacity: 0,
        crossOrigin: this.options.withCredentials ? "use-credentials" : this.options.useCors,
        alt: this.options.alt,
        pane: this.options.pane || this.getPane(),
        interactive: this.options.interactive
      }).addTo(this._map);
      var onOverlayError = function() {
        this._map.removeLayer(image);
        this.fire("error");
        image.off("load", onOverlayLoad, this);
      };
      var onOverlayLoad = function(e) {
        image.off("error", onOverlayLoad, this);
        if (this._map) {
          var newImage = e.target;
          var oldImage = this._currentImage;
          if (newImage._bounds.equals(bounds2) && newImage._bounds.equals(this._map.getBounds())) {
            this._currentImage = newImage;
            if (this.options.position === "front") {
              this.bringToFront();
            } else if (this.options.position === "back") {
              this.bringToBack();
            }
            if (this.options.zIndex) {
              this.setZIndex(this.options.zIndex);
            }
            if (this._map && this._currentImage._map) {
              this._currentImage.setOpacity(this.options.opacity);
            } else {
              this._currentImage._map.removeLayer(this._currentImage);
            }
            if (oldImage && this._map) {
              this._map.removeLayer(oldImage);
            }
            if (oldImage && oldImage._map) {
              oldImage._map.removeLayer(oldImage);
            }
          } else {
            this._map.removeLayer(newImage);
          }
        }
        this.fire("load", {
          bounds: bounds2
        });
      };
      image.once("error", onOverlayError, this);
      image.once("load", onOverlayLoad, this);
    }
  },
  _update: function() {
    if (!this._map) {
      return;
    }
    var zoom = this._map.getZoom();
    var bounds2 = this._map.getBounds();
    if (this._animatingZoom) {
      return;
    }
    if (this._map._panTransition && this._map._panTransition._inProgress) {
      return;
    }
    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      if (this._currentImage) {
        this._currentImage._map.removeLayer(this._currentImage);
        this._currentImage = null;
      }
      return;
    }
    var params = this._buildExportParams();
    import_leaflet10.Util.extend(params, this.options.requestParams);
    if (params) {
      this._requestExport(params, bounds2);
      this.fire("loading", {
        bounds: bounds2
      });
    } else if (this._currentImage) {
      this._currentImage._map.removeLayer(this._currentImage);
      this._currentImage = null;
    }
  },
  _renderPopup: function(latlng, error, results, response) {
    latlng = (0, import_leaflet10.latLng)(latlng);
    if (this._shouldRenderPopup && this._lastClick.equals(latlng)) {
      var content = this._popupFunction(error, results, response);
      if (content) {
        this._popup.setLatLng(latlng).setContent(content).openOn(this._map);
      }
    }
  },
  _resetPopupState: function(e) {
    this._shouldRenderPopup = false;
    this._lastClick = e.latlng;
  },
  _calculateBbox: function() {
    var pixelBounds = this._map.getPixelBounds();
    var sw = this._map.unproject(pixelBounds.getBottomLeft());
    var ne = this._map.unproject(pixelBounds.getTopRight());
    var neProjected = this._map.options.crs.project(ne);
    var swProjected = this._map.options.crs.project(sw);
    var boundsProjected = (0, import_leaflet10.bounds)(neProjected, swProjected);
    return [boundsProjected.getBottomLeft().x, boundsProjected.getBottomLeft().y, boundsProjected.getTopRight().x, boundsProjected.getTopRight().y].join(",");
  },
  _calculateImageSize: function() {
    var bounds2 = this._map.getPixelBounds();
    var size = this._map.getSize();
    var sw = this._map.unproject(bounds2.getBottomLeft());
    var ne = this._map.unproject(bounds2.getTopRight());
    var top = this._map.latLngToLayerPoint(ne).y;
    var bottom = this._map.latLngToLayerPoint(sw).y;
    if (top > 0 || bottom < size.y) {
      size.y = bottom - top;
    }
    return size.x + "," + size.y;
  }
});

// node_modules/esri-leaflet/src/Layers/ImageMapLayer.js
var import_leaflet11 = __toESM(require_leaflet_src());
var ImageMapLayer = RasterLayer.extend({
  options: {
    updateInterval: 150,
    format: "jpgpng",
    transparent: true,
    f: "image"
  },
  query: function() {
    return this.service.query();
  },
  identify: function() {
    return this.service.identify();
  },
  initialize: function(options2) {
    options2 = getUrlParams(options2);
    this.service = ImageService_default(options2);
    this.service.addEventParent(this);
    import_leaflet11.Util.setOptions(this, options2);
  },
  setPixelType: function(pixelType) {
    this.options.pixelType = pixelType;
    this._update();
    return this;
  },
  getPixelType: function() {
    return this.options.pixelType;
  },
  setBandIds: function(bandIds) {
    if (import_leaflet11.Util.isArray(bandIds)) {
      this.options.bandIds = bandIds.join(",");
    } else {
      this.options.bandIds = bandIds.toString();
    }
    this._update();
    return this;
  },
  getBandIds: function() {
    return this.options.bandIds;
  },
  setNoData: function(noData, noDataInterpretation) {
    if (import_leaflet11.Util.isArray(noData)) {
      this.options.noData = noData.join(",");
    } else {
      this.options.noData = noData.toString();
    }
    if (noDataInterpretation) {
      this.options.noDataInterpretation = noDataInterpretation;
    }
    this._update();
    return this;
  },
  getNoData: function() {
    return this.options.noData;
  },
  getNoDataInterpretation: function() {
    return this.options.noDataInterpretation;
  },
  setRenderingRule: function(renderingRule) {
    this.options.renderingRule = renderingRule;
    this._update();
  },
  getRenderingRule: function() {
    return this.options.renderingRule;
  },
  setMosaicRule: function(mosaicRule) {
    this.options.mosaicRule = mosaicRule;
    this._update();
  },
  getMosaicRule: function() {
    return this.options.mosaicRule;
  },
  _getPopupData: function(e) {
    var callback = import_leaflet11.Util.bind(function(error, results, response) {
      if (error) {
        return;
      }
      setTimeout(import_leaflet11.Util.bind(function() {
        this._renderPopup(e.latlng, error, results, response);
      }, this), 300);
    }, this);
    var identifyRequest = this.identify().at(e.latlng);
    if (this.options.mosaicRule) {
      identifyRequest.setMosaicRule(this.options.mosaicRule);
    }
    identifyRequest.run(callback);
    this._shouldRenderPopup = true;
    this._lastClick = e.latlng;
  },
  _buildExportParams: function() {
    var sr = parseInt(this._map.options.crs.code.split(":")[1], 10);
    var params = {
      bbox: this._calculateBbox(),
      size: this._calculateImageSize(),
      format: this.options.format,
      transparent: this.options.transparent,
      bboxSR: sr,
      imageSR: sr
    };
    if (this.options.from && this.options.to) {
      params.time = this.options.from.valueOf() + "," + this.options.to.valueOf();
    }
    if (this.options.pixelType) {
      params.pixelType = this.options.pixelType;
    }
    if (this.options.interpolation) {
      params.interpolation = this.options.interpolation;
    }
    if (this.options.compressionQuality) {
      params.compressionQuality = this.options.compressionQuality;
    }
    if (this.options.bandIds) {
      params.bandIds = this.options.bandIds;
    }
    if (this.options.noData === 0 || this.options.noData) {
      params.noData = this.options.noData;
    }
    if (this.options.noDataInterpretation) {
      params.noDataInterpretation = this.options.noDataInterpretation;
    }
    if (this.service.options.token) {
      params.token = this.service.options.token;
    }
    if (this.options.renderingRule) {
      params.renderingRule = JSON.stringify(this.options.renderingRule);
    }
    if (this.options.mosaicRule) {
      params.mosaicRule = JSON.stringify(this.options.mosaicRule);
    }
    return params;
  },
  _requestExport: function(params, bounds2) {
    if (this.options.f === "json") {
      this.service.request("exportImage", params, function(error, response) {
        if (error) {
          return;
        }
        if (this.options.token) {
          response.href += "?token=" + this.options.token;
        }
        if (this.options.proxy) {
          response.href = this.options.proxy + "?" + response.href;
        }
        this._renderImage(response.href, bounds2);
      }, this);
    } else {
      params.f = "image";
      var fullUrl = this.options.url + "exportImage" + import_leaflet11.Util.getParamString(params);
      if (this.options.proxy) {
        fullUrl = this.options.proxy + "?" + fullUrl;
      }
      this._renderImage(fullUrl, bounds2);
    }
  }
});

// node_modules/esri-leaflet/src/Layers/DynamicMapLayer.js
var import_leaflet12 = __toESM(require_leaflet_src());
var DynamicMapLayer = RasterLayer.extend({
  options: {
    updateInterval: 150,
    layers: false,
    layerDefs: false,
    timeOptions: false,
    format: "png32",
    transparent: true,
    f: "json"
  },
  initialize: function(options2) {
    options2 = getUrlParams(options2);
    this.service = MapService_default(options2);
    this.service.addEventParent(this);
    import_leaflet12.Util.setOptions(this, options2);
  },
  getDynamicLayers: function() {
    return this.options.dynamicLayers;
  },
  setDynamicLayers: function(dynamicLayers) {
    this.options.dynamicLayers = dynamicLayers;
    this._update();
    return this;
  },
  getLayers: function() {
    return this.options.layers;
  },
  setLayers: function(layers) {
    this.options.layers = layers;
    this._update();
    return this;
  },
  getLayerDefs: function() {
    return this.options.layerDefs;
  },
  setLayerDefs: function(layerDefs) {
    this.options.layerDefs = layerDefs;
    this._update();
    return this;
  },
  getTimeOptions: function() {
    return this.options.timeOptions;
  },
  setTimeOptions: function(timeOptions) {
    this.options.timeOptions = timeOptions;
    this._update();
    return this;
  },
  query: function() {
    return this.service.query();
  },
  identify: function() {
    return this.service.identify();
  },
  find: function() {
    return this.service.find();
  },
  _getPopupData: function(e) {
    var callback = import_leaflet12.Util.bind(function(error, featureCollection, response) {
      if (error) {
        return;
      }
      setTimeout(import_leaflet12.Util.bind(function() {
        this._renderPopup(e.latlng, error, featureCollection, response);
      }, this), 300);
    }, this);
    var identifyRequest;
    if (this.options.popup) {
      identifyRequest = this.options.popup.on(this._map).at(e.latlng);
    } else {
      identifyRequest = this.identify().on(this._map).at(e.latlng);
    }
    identifyRequest.params.maxAllowableOffset ? true : identifyRequest.simplify(this._map, 0.5);
    if (!(this.options.popup && this.options.popup.params && this.options.popup.params.layers)) {
      if (this.options.layers) {
        identifyRequest.layers("visible:" + this.options.layers.join(","));
      } else {
        identifyRequest.layers("visible");
      }
    }
    if (this.options.layerDefs && typeof this.options.layerDefs !== "string" && !identifyRequest.params.layerDefs) {
      for (var id in this.options.layerDefs) {
        if (this.options.layerDefs.hasOwnProperty(id)) {
          identifyRequest.layerDef(id, this.options.layerDefs[id]);
        }
      }
    }
    identifyRequest.run(callback);
    this._shouldRenderPopup = true;
    this._lastClick = e.latlng;
  },
  _buildExportParams: function() {
    var sr = parseInt(this._map.options.crs.code.split(":")[1], 10);
    var params = {
      bbox: this._calculateBbox(),
      size: this._calculateImageSize(),
      dpi: 96,
      format: this.options.format,
      transparent: this.options.transparent,
      bboxSR: sr,
      imageSR: sr
    };
    if (this.options.dynamicLayers) {
      params.dynamicLayers = this.options.dynamicLayers;
    }
    if (this.options.layers) {
      if (this.options.layers.length === 0) {
        return;
      } else {
        params.layers = "show:" + this.options.layers.join(",");
      }
    }
    if (this.options.layerDefs) {
      params.layerDefs = typeof this.options.layerDefs === "string" ? this.options.layerDefs : JSON.stringify(this.options.layerDefs);
    }
    if (this.options.timeOptions) {
      params.timeOptions = JSON.stringify(this.options.timeOptions);
    }
    if (this.options.from && this.options.to) {
      params.time = this.options.from.valueOf() + "," + this.options.to.valueOf();
    }
    if (this.service.options.token) {
      params.token = this.service.options.token;
    }
    if (this.options.proxy) {
      params.proxy = this.options.proxy;
    }
    if (this.options.disableCache) {
      params._ts = Date.now();
    }
    return params;
  },
  _requestExport: function(params, bounds2) {
    if (this.options.f === "json") {
      this.service.request("export", params, function(error, response) {
        if (error) {
          return;
        }
        if (this.options.token && response.href) {
          response.href += "?token=" + this.options.token;
        }
        if (this.options.proxy && response.href) {
          response.href = this.options.proxy + "?" + response.href;
        }
        if (response.href) {
          this._renderImage(response.href, bounds2);
        } else {
          this._renderImage(response.imageData, bounds2, response.contentType);
        }
      }, this);
    } else {
      params.f = "image";
      var fullUrl = this.options.url + "export" + import_leaflet12.Util.getParamString(params);
      if (this.options.proxy) {
        fullUrl = this.options.proxy + "?" + fullUrl;
      }
      this._renderImage(fullUrl, bounds2);
    }
  }
});

// node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js
var import_leaflet14 = __toESM(require_leaflet_src());

// node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureGrid.js
var import_leaflet13 = __toESM(require_leaflet_src());
var FeatureGrid = import_leaflet13.Layer.extend({
  // @section
  // @aka GridLayer options
  options: {
    // @option cellSize: Number|Point = 256
    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
    cellSize: 512,
    // @option updateWhenIdle: Boolean = (depends)
    // Load new cells only when panning ends.
    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the
    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
    updateWhenIdle: import_leaflet13.Browser.mobile,
    // @option updateInterval: Number = 150
    // Cells will not update more than once every `updateInterval` milliseconds when panning.
    updateInterval: 150,
    // @option noWrap: Boolean = false
    // Whether the layer is wrapped around the antimeridian. If `true`, the
    // GridLayer will only be displayed once at low zoom levels. Has no
    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
    // cells outside the CRS limits.
    noWrap: false,
    // @option keepBuffer: Number = 1.5
    // When panning the map, keep this many rows and columns of cells before unloading them.
    keepBuffer: 1.5
  },
  initialize: function(options2) {
    import_leaflet13.Util.setOptions(this, options2);
  },
  onAdd: function(map) {
    this._cells = {};
    this._activeCells = {};
    this._resetView();
    this._update();
  },
  onRemove: function(map) {
    this._removeAllCells();
    this._cellZoom = void 0;
  },
  // @method isLoading: Boolean
  // Returns `true` if any cell in the grid layer has not finished loading.
  isLoading: function() {
    return this._loading;
  },
  // @method redraw: this
  // Causes the layer to clear all the cells and request them again.
  redraw: function() {
    if (this._map) {
      this._removeAllCells();
      this._update();
    }
    return this;
  },
  getEvents: function() {
    var events = {
      viewprereset: this._invalidateAll,
      viewreset: this._resetView,
      zoom: this._resetView,
      moveend: this._onMoveEnd
    };
    if (!this.options.updateWhenIdle) {
      if (!this._onMove) {
        this._onMove = import_leaflet13.Util.throttle(
          this._onMoveEnd,
          this.options.updateInterval,
          this
        );
      }
      events.move = this._onMove;
    }
    return events;
  },
  // @section Extension methods
  // Layers extending `GridLayer` shall reimplement the following method.
  // @method createCell(coords: Object, done?: Function): HTMLElement
  // Called only internally, must be overridden by classes extending `GridLayer`.
  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
  // is specified, it must be called when the cell has finished loading and drawing.
  createCell: function() {
    return document.createElement("div");
  },
  removeCell: function() {
    return;
  },
  reuseCell: function() {
    return;
  },
  cellLeave: function() {
    return;
  },
  cellEnter: function() {
    return;
  },
  // @section
  // @method getCellSize: Point
  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.
  getCellSize: function() {
    var s = this.options.cellSize;
    return s instanceof import_leaflet13.Point ? s : new import_leaflet13.Point(s, s);
  },
  _pruneCells: function() {
    if (!this._map) {
      return;
    }
    var key, cell;
    for (key in this._cells) {
      cell = this._cells[key];
      cell.retain = cell.current;
    }
    for (key in this._cells) {
      cell = this._cells[key];
      if (cell.current && !cell.active) {
        var coords = cell.coords;
        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
        }
      }
    }
    for (key in this._cells) {
      if (!this._cells[key].retain) {
        this._removeCell(key);
      }
    }
  },
  _removeAllCells: function() {
    for (var key in this._cells) {
      this._removeCell(key);
    }
  },
  _invalidateAll: function() {
    this._removeAllCells();
    this._cellZoom = void 0;
  },
  _retainParent: function(x, y, z, minZoom) {
    var x2 = Math.floor(x / 2);
    var y2 = Math.floor(y / 2);
    var z2 = z - 1;
    var coords2 = new import_leaflet13.Point(+x2, +y2);
    coords2.z = +z2;
    var key = this._cellCoordsToKey(coords2);
    var cell = this._cells[key];
    if (cell && cell.active) {
      cell.retain = true;
      return true;
    } else if (cell && cell.loaded) {
      cell.retain = true;
    }
    if (z2 > minZoom) {
      return this._retainParent(x2, y2, z2, minZoom);
    }
    return false;
  },
  _retainChildren: function(x, y, z, maxZoom) {
    for (var i = 2 * x; i < 2 * x + 2; i++) {
      for (var j = 2 * y; j < 2 * y + 2; j++) {
        var coords = new import_leaflet13.Point(i, j);
        coords.z = z + 1;
        var key = this._cellCoordsToKey(coords);
        var cell = this._cells[key];
        if (cell && cell.active) {
          cell.retain = true;
          continue;
        } else if (cell && cell.loaded) {
          cell.retain = true;
        }
        if (z + 1 < maxZoom) {
          this._retainChildren(i, j, z + 1, maxZoom);
        }
      }
    }
  },
  _resetView: function(e) {
    var animating = e && (e.pinch || e.flyTo);
    if (animating) {
      return;
    }
    this._setView(
      this._map.getCenter(),
      this._map.getZoom(),
      animating,
      animating
    );
  },
  _setView: function(center, zoom, noPrune, noUpdate) {
    var cellZoom = Math.round(zoom);
    if (!noUpdate) {
      this._cellZoom = cellZoom;
      if (this._abortLoading) {
        this._abortLoading();
      }
      this._resetGrid();
      if (cellZoom !== void 0) {
        this._update(center);
      }
      if (!noPrune) {
        this._pruneCells();
      }
      this._noPrune = !!noPrune;
    }
  },
  _resetGrid: function() {
    var map = this._map;
    var crs = map.options.crs;
    var cellSize = this._cellSize = this.getCellSize();
    var cellZoom = this._cellZoom;
    var bounds2 = this._map.getPixelWorldBounds(this._cellZoom);
    if (bounds2) {
      this._globalCellRange = this._pxBoundsToCellRange(bounds2);
    }
    this._wrapX = crs.wrapLng && !this.options.noWrap && [
      Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x),
      Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)
    ];
    this._wrapY = crs.wrapLat && !this.options.noWrap && [
      Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x),
      Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)
    ];
  },
  _onMoveEnd: function(e) {
    var animating = e && (e.pinch || e.flyTo);
    if (animating || !this._map || this._map._animatingZoom) {
      return;
    }
    this._update();
  },
  _getCelldPixelBounds: function(center) {
    var map = this._map;
    var mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom();
    var scale = map.getZoomScale(mapZoom, this._cellZoom);
    var pixelCenter = map.project(center, this._cellZoom).floor();
    var halfSize = map.getSize().divideBy(scale * 2);
    return new import_leaflet13.Bounds(
      pixelCenter.subtract(halfSize),
      pixelCenter.add(halfSize)
    );
  },
  // Private method to load cells in the grid's active zoom level according to map bounds
  _update: function(center) {
    var map = this._map;
    if (!map) {
      return;
    }
    var zoom = Math.round(map.getZoom());
    if (center === void 0) {
      center = map.getCenter();
    }
    var pixelBounds = this._getCelldPixelBounds(center);
    var cellRange = this._pxBoundsToCellRange(pixelBounds);
    var cellCenter = cellRange.getCenter();
    var queue = [];
    var margin = this.options.keepBuffer;
    var noPruneRange = new import_leaflet13.Bounds(
      cellRange.getBottomLeft().subtract([margin, -margin]),
      cellRange.getTopRight().add([margin, -margin])
    );
    if (!(isFinite(cellRange.min.x) && isFinite(cellRange.min.y) && isFinite(cellRange.max.x) && isFinite(cellRange.max.y))) {
      throw new Error("Attempted to load an infinite number of cells");
    }
    for (var key in this._cells) {
      var c = this._cells[key].coords;
      if (c.z !== this._cellZoom || !noPruneRange.contains(new import_leaflet13.Point(c.x, c.y))) {
        this._cells[key].current = false;
      }
    }
    if (Math.abs(zoom - this._cellZoom) > 1) {
      this._setView(center, zoom);
      return;
    }
    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {
      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {
        var coords = new import_leaflet13.Point(i, j);
        coords.z = this._cellZoom;
        if (!this._isValidCell(coords)) {
          continue;
        }
        var cell = this._cells[this._cellCoordsToKey(coords)];
        if (cell) {
          cell.current = true;
        } else {
          queue.push(coords);
        }
      }
    }
    queue.sort(function(a, b) {
      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);
    });
    if (queue.length !== 0) {
      if (!this._loading) {
        this._loading = true;
      }
      for (i = 0; i < queue.length; i++) {
        var _key = this._cellCoordsToKey(queue[i]);
        var _coords = this._keyToCellCoords(_key);
        if (this._activeCells[_coords]) {
          this._reuseCell(queue[i]);
        } else {
          this._createCell(queue[i]);
        }
      }
    }
  },
  _isValidCell: function(coords) {
    var crs = this._map.options.crs;
    if (!crs.infinite) {
      var bounds2 = this._globalCellRange;
      if (!crs.wrapLng && (coords.x < bounds2.min.x || coords.x > bounds2.max.x) || !crs.wrapLat && (coords.y < bounds2.min.y || coords.y > bounds2.max.y)) {
        return false;
      }
    }
    if (!this.options.bounds) {
      return true;
    }
    var cellBounds = this._cellCoordsToBounds(coords);
    return (0, import_leaflet13.toLatLngBounds)(this.options.bounds).overlaps(cellBounds);
  },
  _keyToBounds: function(key) {
    return this._cellCoordsToBounds(this._keyToCellCoords(key));
  },
  _cellCoordsToNwSe: function(coords) {
    var map = this._map;
    var cellSize = this.getCellSize();
    var nwPoint = coords.scaleBy(cellSize);
    var sePoint = nwPoint.add(cellSize);
    var nw = map.unproject(nwPoint, coords.z);
    var se = map.unproject(sePoint, coords.z);
    return [nw, se];
  },
  // converts cell coordinates to its geographical bounds
  _cellCoordsToBounds: function(coords) {
    var bp = this._cellCoordsToNwSe(coords);
    var bounds2 = new import_leaflet13.LatLngBounds(bp[0], bp[1]);
    if (!this.options.noWrap) {
      bounds2 = this._map.wrapLatLngBounds(bounds2);
    }
    return bounds2;
  },
  // converts cell coordinates to key for the cell cache
  _cellCoordsToKey: function(coords) {
    return coords.x + ":" + coords.y + ":" + coords.z;
  },
  // converts cell cache key to coordinates
  _keyToCellCoords: function(key) {
    var k = key.split(":");
    var coords = new import_leaflet13.Point(+k[0], +k[1]);
    coords.z = +k[2];
    return coords;
  },
  _removeCell: function(key) {
    var cell = this._cells[key];
    if (!cell) {
      return;
    }
    var coords = this._keyToCellCoords(key);
    var wrappedCoords = this._wrapCoords(coords);
    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));
    cell.current = false;
    delete this._cells[key];
    this._activeCells[key] = cell;
    this.cellLeave(cellBounds, wrappedCoords, key);
    this.fire("cellleave", {
      key,
      coords: wrappedCoords,
      bounds: cellBounds
    });
  },
  _reuseCell: function(coords) {
    var key = this._cellCoordsToKey(coords);
    this._cells[key] = this._activeCells[key];
    this._cells[key].current = true;
    var wrappedCoords = this._wrapCoords(coords);
    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));
    this.cellEnter(cellBounds, wrappedCoords, key);
    this.fire("cellenter", {
      key,
      coords: wrappedCoords,
      bounds: cellBounds
    });
  },
  _createCell: function(coords) {
    var key = this._cellCoordsToKey(coords);
    var wrappedCoords = this._wrapCoords(coords);
    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));
    this.createCell(cellBounds, wrappedCoords, key);
    this.fire("cellcreate", {
      key,
      coords: wrappedCoords,
      bounds: cellBounds
    });
    this._cells[key] = {
      coords,
      current: true
    };
    import_leaflet13.Util.requestAnimFrame(this._pruneCells, this);
  },
  _cellReady: function(coords, err, cell) {
    var key = this._cellCoordsToKey(coords);
    cell = this._cells[key];
    if (!cell) {
      return;
    }
    cell.loaded = +/* @__PURE__ */ new Date();
    cell.active = true;
  },
  _getCellPos: function(coords) {
    return coords.scaleBy(this.getCellSize());
  },
  _wrapCoords: function(coords) {
    var newCoords = new import_leaflet13.Point(
      this._wrapX ? import_leaflet13.Util.wrapNum(coords.x, this._wrapX) : coords.x,
      this._wrapY ? import_leaflet13.Util.wrapNum(coords.y, this._wrapY) : coords.y
    );
    newCoords.z = coords.z;
    return newCoords;
  },
  _pxBoundsToCellRange: function(bounds2) {
    var cellSize = this.getCellSize();
    return new import_leaflet13.Bounds(
      bounds2.min.unscaleBy(cellSize).floor(),
      bounds2.max.unscaleBy(cellSize).ceil().subtract([1, 1])
    );
  }
});

// node_modules/tiny-binary-search/index.js
function BinarySearchIndex(values) {
  this.values = [].concat(values || []);
}
BinarySearchIndex.prototype.query = function(value) {
  var index = this.getIndex(value);
  return this.values[index];
};
BinarySearchIndex.prototype.getIndex = function getIndex(value) {
  if (this.dirty) {
    this.sort();
  }
  var minIndex = 0;
  var maxIndex = this.values.length - 1;
  var currentIndex;
  var currentElement;
  while (minIndex <= maxIndex) {
    currentIndex = (minIndex + maxIndex) / 2 | 0;
    currentElement = this.values[Math.round(currentIndex)];
    if (+currentElement.value < +value) {
      minIndex = currentIndex + 1;
    } else if (+currentElement.value > +value) {
      maxIndex = currentIndex - 1;
    } else {
      return currentIndex;
    }
  }
  return Math.abs(~maxIndex);
};
BinarySearchIndex.prototype.between = function between(start, end) {
  var startIndex = this.getIndex(start);
  var endIndex = this.getIndex(end);
  if (startIndex === 0 && endIndex === 0) {
    return [];
  }
  while (this.values[startIndex - 1] && this.values[startIndex - 1].value === start) {
    startIndex--;
  }
  while (this.values[endIndex + 1] && this.values[endIndex + 1].value === end) {
    endIndex++;
  }
  if (this.values[endIndex] && this.values[endIndex].value === end && this.values[endIndex + 1]) {
    endIndex++;
  }
  return this.values.slice(startIndex, endIndex);
};
BinarySearchIndex.prototype.insert = function insert(item) {
  this.values.splice(this.getIndex(item.value), 0, item);
  return this;
};
BinarySearchIndex.prototype.bulkAdd = function bulkAdd(items, sort2) {
  this.values = this.values.concat([].concat(items || []));
  if (sort2) {
    this.sort();
  } else {
    this.dirty = true;
  }
  return this;
};
BinarySearchIndex.prototype.sort = function sort() {
  this.values.sort(function(a, b) {
    return +b.value - +a.value;
  }).reverse();
  this.dirty = false;
  return this;
};
var tiny_binary_search_default = BinarySearchIndex;

// node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureManager.js
var FeatureManager = FeatureGrid.extend({
  /**
   * Options
   */
  options: {
    attribution: null,
    where: "1=1",
    fields: ["*"],
    from: false,
    to: false,
    timeField: false,
    timeFilterMode: "server",
    simplifyFactor: 0,
    precision: 6,
    fetchAllFeatures: false
  },
  /**
   * Constructor
   */
  initialize: function(options2) {
    FeatureGrid.prototype.initialize.call(this, options2);
    options2 = getUrlParams(options2);
    options2 = import_leaflet14.Util.setOptions(this, options2);
    this.service = FeatureLayerService_default(options2);
    this.service.addEventParent(this);
    if (this.options.fields[0] !== "*") {
      var oidCheck = false;
      for (var i = 0; i < this.options.fields.length; i++) {
        if (this.options.fields[i].match(/^(OBJECTID|FID|OID|ID)$/i)) {
          oidCheck = true;
        }
      }
      if (oidCheck === false) {
        warn(
          "no known esriFieldTypeOID field detected in fields Array.  Please add an attribute field containing unique IDs to ensure the layer can be drawn correctly."
        );
      }
    }
    if (this.options.timeField.start && this.options.timeField.end) {
      this._startTimeIndex = new tiny_binary_search_default();
      this._endTimeIndex = new tiny_binary_search_default();
    } else if (this.options.timeField) {
      this._timeIndex = new tiny_binary_search_default();
    }
    this._cache = {};
    this._currentSnapshot = [];
    this._activeRequests = 0;
  },
  /**
   * Layer Interface
   */
  onAdd: function(map) {
    setEsriAttribution(map);
    this.service.metadata(function(err, metadata) {
      if (!err) {
        var supportedFormats = metadata.supportedQueryFormats;
        var forceJsonFormat = false;
        if (this.service.options.isModern === false || this.options.fetchAllFeatures) {
          forceJsonFormat = true;
        }
        if (!forceJsonFormat && supportedFormats && supportedFormats.indexOf("geoJSON") !== -1) {
          this.service.options.isModern = true;
        }
        if (metadata.objectIdField) {
          this.service.options.idAttribute = metadata.objectIdField;
        }
        if (!this.options.attribution && map.attributionControl && metadata.copyrightText) {
          this.options.attribution = metadata.copyrightText;
          map.attributionControl.addAttribution(this.getAttribution());
        }
      }
    }, this);
    map.on("zoomend", this._handleZoomChange, this);
    return FeatureGrid.prototype.onAdd.call(this, map);
  },
  onRemove: function(map) {
    removeEsriAttribution(map);
    map.off("zoomend", this._handleZoomChange, this);
    return FeatureGrid.prototype.onRemove.call(this, map);
  },
  getAttribution: function() {
    return this.options.attribution;
  },
  /**
   * Feature Management
   */
  createCell: function(bounds2, coords) {
    if (this._visibleZoom()) {
      this._requestFeatures(bounds2, coords);
    }
  },
  _requestFeatures: function(bounds2, coords, callback, offset) {
    this._activeRequests++;
    offset = offset || 0;
    var originalWhere = this.options.where;
    if (this._activeRequests === 1) {
      this.fire(
        "loading",
        {
          bounds: bounds2
        },
        true
      );
    }
    return this._buildQuery(bounds2, offset).run(
      function(error, featureCollection, response) {
        if (response && response.exceededTransferLimit) {
          this.fire("drawlimitexceeded");
        }
        if (this.options.where !== originalWhere) {
          return;
        }
        if (!error && featureCollection && featureCollection.features.length) {
          import_leaflet14.Util.requestAnimFrame(
            import_leaflet14.Util.bind(function() {
              this._addFeatures(featureCollection.features, coords);
              this._postProcessFeatures(bounds2);
            }, this)
          );
        }
        if (!error && featureCollection && !featureCollection.features.length) {
          this._postProcessFeatures(bounds2);
        }
        if (error) {
          this._postProcessFeatures(bounds2);
        }
        if (callback) {
          callback.call(this, error, featureCollection);
        }
        if (response && (response.exceededTransferLimit || response.properties && response.properties.exceededTransferLimit) && this.options.fetchAllFeatures) {
          this._requestFeatures(bounds2, coords, callback, offset + featureCollection.features.length);
        }
      },
      this
    );
  },
  _postProcessFeatures: function(bounds2) {
    this._activeRequests--;
    if (this._activeRequests <= 0) {
      this.fire("load", {
        bounds: bounds2
      });
    }
  },
  _cacheKey: function(coords) {
    return coords.z + ":" + coords.x + ":" + coords.y;
  },
  _addFeatures: function(features, coords) {
    if (coords) {
      var key = this._cacheKey(coords);
      this._cache[key] = this._cache[key] || [];
    }
    for (var i = features.length - 1; i >= 0; i--) {
      var id = features[i].id;
      if (this._currentSnapshot.indexOf(id) === -1) {
        this._currentSnapshot.push(id);
      }
      if (typeof key !== "undefined" && this._cache[key].indexOf(id) === -1) {
        this._cache[key].push(id);
      }
    }
    if (this.options.timeField) {
      this._buildTimeIndexes(features);
    }
    this.createLayers(features);
  },
  _buildQuery: function(bounds2, offset) {
    var query2 = this.service.query().intersects(bounds2).where(this.options.where).fields(this.options.fields).precision(this.options.precision);
    if (this.options.fetchAllFeatures && !isNaN(parseInt(offset))) {
      query2 = query2.offset(offset);
    }
    query2.params["resultType"] = "tile";
    if (this.options.requestParams) {
      import_leaflet14.Util.extend(query2.params, this.options.requestParams);
    }
    if (this.options.simplifyFactor) {
      query2.simplify(this._map, this.options.simplifyFactor);
    }
    if (this.options.timeFilterMode === "server" && this.options.from && this.options.to) {
      query2.between(this.options.from, this.options.to);
    }
    return query2;
  },
  /**
   * Where Methods
   */
  setWhere: function(where, callback, context) {
    this.options.where = where && where.length ? where : "1=1";
    var oldSnapshot = [];
    var newSnapshot = [];
    var pendingRequests = 0;
    var requestError = null;
    var requestCallback = import_leaflet14.Util.bind(function(error, featureCollection) {
      if (error) {
        requestError = error;
      }
      if (featureCollection) {
        for (var i2 = featureCollection.features.length - 1; i2 >= 0; i2--) {
          newSnapshot.push(featureCollection.features[i2].id);
        }
      }
      pendingRequests--;
      if (pendingRequests <= 0 && this._visibleZoom() && where === this.options.where) {
        this._currentSnapshot = newSnapshot;
        import_leaflet14.Util.requestAnimFrame(
          import_leaflet14.Util.bind(function() {
            this.removeLayers(oldSnapshot);
            this.addLayers(newSnapshot);
            if (callback) {
              callback.call(context, requestError);
            }
          }, this)
        );
      }
    }, this);
    for (var i = this._currentSnapshot.length - 1; i >= 0; i--) {
      oldSnapshot.push(this._currentSnapshot[i]);
    }
    this._cache = {};
    for (var key in this._cells) {
      pendingRequests++;
      var coords = this._keyToCellCoords(key);
      var bounds2 = this._cellCoordsToBounds(coords);
      this._requestFeatures(bounds2, coords, requestCallback);
    }
    return this;
  },
  getWhere: function() {
    return this.options.where;
  },
  /**
   * Time Range Methods
   */
  getTimeRange: function() {
    return [this.options.from, this.options.to];
  },
  setTimeRange: function(from, to, callback, context) {
    var oldFrom = this.options.from;
    var oldTo = this.options.to;
    var pendingRequests = 0;
    var requestError = null;
    var requestCallback = import_leaflet14.Util.bind(function(error) {
      if (error) {
        requestError = error;
      }
      this._filterExistingFeatures(oldFrom, oldTo, from, to);
      pendingRequests--;
      if (callback && pendingRequests <= 0) {
        callback.call(context, requestError);
      }
    }, this);
    this.options.from = from;
    this.options.to = to;
    this._filterExistingFeatures(oldFrom, oldTo, from, to);
    if (this.options.timeFilterMode === "server") {
      for (var key in this._cells) {
        pendingRequests++;
        var coords = this._keyToCellCoords(key);
        var bounds2 = this._cellCoordsToBounds(coords);
        this._requestFeatures(bounds2, coords, requestCallback);
      }
    }
    return this;
  },
  refresh: function() {
    this.setWhere(this.options.where);
  },
  _filterExistingFeatures: function(oldFrom, oldTo, newFrom, newTo) {
    var layersToRemove = oldFrom && oldTo ? this._getFeaturesInTimeRange(oldFrom, oldTo) : this._currentSnapshot;
    var layersToAdd = this._getFeaturesInTimeRange(newFrom, newTo);
    if (layersToAdd.indexOf) {
      for (var i = 0; i < layersToAdd.length; i++) {
        var shouldRemoveLayer = layersToRemove.indexOf(layersToAdd[i]);
        if (shouldRemoveLayer >= 0) {
          layersToRemove.splice(shouldRemoveLayer, 1);
        }
      }
    }
    import_leaflet14.Util.requestAnimFrame(
      import_leaflet14.Util.bind(function() {
        this.removeLayers(layersToRemove);
        this.addLayers(layersToAdd);
      }, this)
    );
  },
  _getFeaturesInTimeRange: function(start, end) {
    var ids = [];
    var search;
    if (this.options.timeField.start && this.options.timeField.end) {
      var startTimes = this._startTimeIndex.between(start, end);
      var endTimes = this._endTimeIndex.between(start, end);
      search = startTimes.concat(endTimes);
    } else if (this._timeIndex) {
      search = this._timeIndex.between(start, end);
    } else {
      warn(
        "You must set timeField in the layer constructor in order to manipulate the start and end time filter."
      );
      return [];
    }
    for (var i = search.length - 1; i >= 0; i--) {
      ids.push(search[i].id);
    }
    return ids;
  },
  _buildTimeIndexes: function(geojson) {
    var i;
    var feature;
    if (this.options.timeField.start && this.options.timeField.end) {
      var startTimeEntries = [];
      var endTimeEntries = [];
      for (i = geojson.length - 1; i >= 0; i--) {
        feature = geojson[i];
        startTimeEntries.push({
          id: feature.id,
          value: new Date(feature.properties[this.options.timeField.start])
        });
        endTimeEntries.push({
          id: feature.id,
          value: new Date(feature.properties[this.options.timeField.end])
        });
      }
      this._startTimeIndex.bulkAdd(startTimeEntries);
      this._endTimeIndex.bulkAdd(endTimeEntries);
    } else {
      var timeEntries = [];
      for (i = geojson.length - 1; i >= 0; i--) {
        feature = geojson[i];
        timeEntries.push({
          id: feature.id,
          value: new Date(feature.properties[this.options.timeField])
        });
      }
      this._timeIndex.bulkAdd(timeEntries);
    }
  },
  _featureWithinTimeRange: function(feature) {
    if (!this.options.from || !this.options.to) {
      return true;
    }
    var from = +this.options.from.valueOf();
    var to = +this.options.to.valueOf();
    if (typeof this.options.timeField === "string") {
      var date = +feature.properties[this.options.timeField];
      return date >= from && date <= to;
    }
    if (this.options.timeField.start && this.options.timeField.end) {
      var startDate = +feature.properties[this.options.timeField.start];
      var endDate = +feature.properties[this.options.timeField.end];
      return startDate >= from && startDate <= to || endDate >= from && endDate <= to || startDate <= from && endDate >= to;
    }
  },
  _visibleZoom: function() {
    if (!this._map) {
      return false;
    }
    var zoom = this._map.getZoom();
    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      return false;
    } else {
      return true;
    }
  },
  _handleZoomChange: function() {
    if (!this._visibleZoom()) {
      this.removeLayers(this._currentSnapshot);
    } else {
      for (var i in this._cells) {
        var coords = this._cells[i].coords;
        var key = this._cacheKey(coords);
        if (this._cache[key]) {
          this.addLayers(this._cache[key]);
        }
      }
    }
  },
  /**
   * Service Methods
   */
  authenticate: function(token) {
    this.service.authenticate(token);
    return this;
  },
  metadata: function(callback, context) {
    this.service.metadata(callback, context);
    return this;
  },
  query: function() {
    return this.service.query();
  },
  _getMetadata: function(callback) {
    if (this._metadata) {
      var error;
      callback(error, this._metadata);
    } else {
      this.metadata(
        import_leaflet14.Util.bind(function(error2, response) {
          this._metadata = response;
          callback(error2, this._metadata);
        }, this)
      );
    }
  },
  addFeature: function(feature, callback, context) {
    this.addFeatures(feature, callback, context);
  },
  addFeatures: function(features, callback, context) {
    this._getMetadata(
      import_leaflet14.Util.bind(function(error, metadata) {
        if (error) {
          if (callback) {
            callback.call(this, error, null);
          }
          return;
        }
        var featuresArray = features.features ? features.features : [features];
        this.service.addFeatures(
          features,
          import_leaflet14.Util.bind(function(error2, response) {
            if (!error2) {
              for (var i = featuresArray.length - 1; i >= 0; i--) {
                featuresArray[i].properties[metadata.objectIdField] = featuresArray.length > 1 ? response[i].objectId : response.objectId;
                featuresArray[i].id = featuresArray.length > 1 ? response[i].objectId : response.objectId;
              }
              this._addFeatures(featuresArray);
            }
            if (callback) {
              callback.call(context, error2, response);
            }
          }, this)
        );
      }, this)
    );
  },
  updateFeature: function(feature, callback, context) {
    this.updateFeatures(feature, callback, context);
  },
  updateFeatures: function(features, callback, context) {
    var featuresArray = features.features ? features.features : [features];
    this.service.updateFeatures(
      features,
      function(error, response) {
        if (!error) {
          for (var i = featuresArray.length - 1; i >= 0; i--) {
            this.removeLayers([featuresArray[i].id], true);
          }
          this._addFeatures(featuresArray);
        }
        if (callback) {
          callback.call(context, error, response);
        }
      },
      this
    );
  },
  deleteFeature: function(id, callback, context) {
    this.deleteFeatures(id, callback, context);
  },
  deleteFeatures: function(ids, callback, context) {
    return this.service.deleteFeatures(
      ids,
      function(error, response) {
        var responseArray = response.length ? response : [response];
        if (!error && responseArray.length > 0) {
          for (var i = responseArray.length - 1; i >= 0; i--) {
            this.removeLayers([responseArray[i].objectId], true);
          }
        }
        if (callback) {
          callback.call(context, error, response);
        }
      },
      this
    );
  }
});

// node_modules/esri-leaflet/src/Layers/FeatureLayer/FeatureLayer.js
var import_leaflet15 = __toESM(require_leaflet_src());
var FeatureLayer = FeatureManager.extend({
  options: {
    cacheLayers: true
  },
  /**
   * Constructor
   */
  initialize: function(options2) {
    FeatureManager.prototype.initialize.call(this, options2);
    this._originalStyle = this.options.style;
    this._layers = {};
  },
  /**
   * Layer Interface
   */
  onRemove: function(map) {
    for (var i in this._layers) {
      map.removeLayer(this._layers[i]);
      this.fire("removefeature", {
        feature: this._layers[i].feature,
        permanent: false
      }, true);
    }
    return FeatureManager.prototype.onRemove.call(this, map);
  },
  createNewLayer: function(geojson) {
    var layer = import_leaflet15.GeoJSON.geometryToLayer(geojson, this.options);
    if (layer) {
      layer.defaultOptions = layer.options;
    }
    return layer;
  },
  _updateLayer: function(layer, geojson) {
    var latlngs = [];
    var coordsToLatLng = this.options.coordsToLatLng || import_leaflet15.GeoJSON.coordsToLatLng;
    if (geojson.properties) {
      layer.feature.properties = geojson.properties;
    }
    switch (geojson.geometry.type) {
      case "Point":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLng(geojson.geometry.coordinates);
        layer.setLatLng(latlngs);
        break;
      case "LineString":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 0, coordsToLatLng);
        layer.setLatLngs(latlngs);
        break;
      case "MultiLineString":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 1, coordsToLatLng);
        layer.setLatLngs(latlngs);
        break;
      case "Polygon":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 1, coordsToLatLng);
        layer.setLatLngs(latlngs);
        break;
      case "MultiPolygon":
        latlngs = import_leaflet15.GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 2, coordsToLatLng);
        layer.setLatLngs(latlngs);
        break;
    }
  },
  /**
   * Feature Management Methods
   */
  createLayers: function(features) {
    for (var i = features.length - 1; i >= 0; i--) {
      var geojson = features[i];
      var layer = this._layers[geojson.id];
      var newLayer;
      if (this._visibleZoom() && layer && !this._map.hasLayer(layer) && (!this.options.timeField || this._featureWithinTimeRange(geojson))) {
        this._map.addLayer(layer);
        this.fire("addfeature", {
          feature: layer.feature
        }, true);
      }
      if (layer && this.options.simplifyFactor > 0 && (layer.setLatLngs || layer.setLatLng)) {
        this._updateLayer(layer, geojson);
      }
      if (!layer) {
        newLayer = this.createNewLayer(geojson);
        if (!newLayer) {
          warn("invalid GeoJSON encountered");
        } else {
          newLayer.feature = geojson;
          newLayer.addEventParent(this);
          if (this.options.onEachFeature) {
            this.options.onEachFeature(newLayer.feature, newLayer);
          }
          this._layers[newLayer.feature.id] = newLayer;
          this.setFeatureStyle(newLayer.feature.id, this.options.style);
          this.fire("createfeature", {
            feature: newLayer.feature
          }, true);
          if (this._visibleZoom() && (!this.options.timeField || this.options.timeField && this._featureWithinTimeRange(geojson))) {
            this._map.addLayer(newLayer);
          }
        }
      }
    }
  },
  addLayers: function(ids) {
    for (var i = ids.length - 1; i >= 0; i--) {
      var layer = this._layers[ids[i]];
      if (layer && (!this.options.timeField || this._featureWithinTimeRange(layer.feature))) {
        this._map.addLayer(layer);
      }
    }
  },
  removeLayers: function(ids, permanent) {
    for (var i = ids.length - 1; i >= 0; i--) {
      var id = ids[i];
      var layer = this._layers[id];
      if (layer) {
        this.fire("removefeature", {
          feature: layer.feature,
          permanent
        }, true);
        this._map.removeLayer(layer);
      }
      if (layer && permanent) {
        delete this._layers[id];
      }
    }
  },
  cellEnter: function(bounds2, coords) {
    if (this._visibleZoom() && !this._zooming && this._map) {
      import_leaflet15.Util.requestAnimFrame(import_leaflet15.Util.bind(function() {
        var cacheKey = this._cacheKey(coords);
        var cellKey = this._cellCoordsToKey(coords);
        var layers = this._cache[cacheKey];
        if (this._activeCells[cellKey] && layers) {
          this.addLayers(layers);
        }
      }, this));
    }
  },
  cellLeave: function(bounds2, coords) {
    if (!this._zooming) {
      import_leaflet15.Util.requestAnimFrame(import_leaflet15.Util.bind(function() {
        if (this._map) {
          var cacheKey = this._cacheKey(coords);
          var cellKey = this._cellCoordsToKey(coords);
          var layers = this._cache[cacheKey];
          var mapBounds = this._map.getBounds();
          if (!this._activeCells[cellKey] && layers) {
            var removable = true;
            for (var i = 0; i < layers.length; i++) {
              var layer = this._layers[layers[i]];
              if (layer && layer.getBounds && mapBounds.intersects(layer.getBounds())) {
                removable = false;
              }
            }
            if (removable) {
              this.removeLayers(layers, !this.options.cacheLayers);
            }
            if (!this.options.cacheLayers && removable) {
              delete this._cache[cacheKey];
              delete this._cells[cellKey];
              delete this._activeCells[cellKey];
            }
          }
        }
      }, this));
    }
  },
  /**
   * Styling Methods
   */
  resetStyle: function() {
    this.options.style = this._originalStyle;
    this.eachFeature(function(layer) {
      this.resetFeatureStyle(layer.feature.id);
    }, this);
    return this;
  },
  setStyle: function(style) {
    this.options.style = style;
    this.eachFeature(function(layer) {
      this.setFeatureStyle(layer.feature.id, style);
    }, this);
    return this;
  },
  resetFeatureStyle: function(id) {
    var layer = this._layers[id];
    var style = this._originalStyle || import_leaflet15.Path.prototype.options;
    if (layer) {
      import_leaflet15.Util.extend(layer.options, layer.defaultOptions);
      this.setFeatureStyle(id, style);
    }
    return this;
  },
  setFeatureStyle: function(id, style) {
    var layer = this._layers[id];
    if (typeof style === "function") {
      style = style(layer.feature);
    }
    if (layer.setStyle) {
      layer.setStyle(style);
    }
    return this;
  },
  /**
   * Utility Methods
   */
  eachActiveFeature: function(fn, context) {
    if (this._map) {
      var activeBounds = this._map.getBounds();
      for (var i in this._layers) {
        if (this._currentSnapshot.indexOf(this._layers[i].feature.id) !== -1) {
          if (typeof this._layers[i].getLatLng === "function" && activeBounds.contains(this._layers[i].getLatLng())) {
            fn.call(context, this._layers[i]);
          } else if (typeof this._layers[i].getBounds === "function" && activeBounds.intersects(this._layers[i].getBounds())) {
            fn.call(context, this._layers[i]);
          }
        }
      }
    }
    return this;
  },
  eachFeature: function(fn, context) {
    for (var i in this._layers) {
      fn.call(context, this._layers[i]);
    }
    return this;
  },
  getFeature: function(id) {
    return this._layers[id];
  },
  bringToBack: function() {
    this.eachFeature(function(layer) {
      if (layer.bringToBack) {
        layer.bringToBack();
      }
    });
  },
  bringToFront: function() {
    this.eachFeature(function(layer) {
      if (layer.bringToFront) {
        layer.bringToFront();
      }
    });
  },
  redraw: function(id) {
    if (id) {
      this._redraw(id);
    }
    return this;
  },
  _redraw: function(id) {
    var layer = this._layers[id];
    var geojson = layer.feature;
    if (layer && layer.setIcon && this.options.pointToLayer) {
      if (this.options.pointToLayer) {
        var getIcon = this.options.pointToLayer(geojson, (0, import_leaflet15.latLng)(geojson.geometry.coordinates[1], geojson.geometry.coordinates[0]));
        var updatedIcon = getIcon.options.icon;
        layer.setIcon(updatedIcon);
      }
    }
    if (layer && layer.setStyle && this.options.pointToLayer) {
      var getStyle = this.options.pointToLayer(geojson, (0, import_leaflet15.latLng)(geojson.geometry.coordinates[1], geojson.geometry.coordinates[0]));
      var updatedStyle = getStyle.options;
      this.setFeatureStyle(geojson.id, updatedStyle);
    }
    if (layer && layer.setStyle && this.options.style) {
      this.resetStyle(geojson.id);
    }
  }
});

// node_modules/esri-leaflet-geocoder/src/helper.js
var WorldGeocodingServiceUrl = "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/";

// node_modules/esri-leaflet-geocoder/src/Tasks/Geocode.js
var Geocode = Task.extend({
  path: "findAddressCandidates",
  params: {
    outSr: 4326,
    forStorage: false,
    outFields: "*",
    maxLocations: 20
  },
  setters: {
    "address": "address",
    "neighborhood": "neighborhood",
    "city": "city",
    "subregion": "subregion",
    "region": "region",
    "postal": "postal",
    "country": "country",
    "text": "singleLine",
    "category": "category",
    "token": "token",
    "key": "magicKey",
    "fields": "outFields",
    "forStorage": "forStorage",
    "maxLocations": "maxLocations",
    // World Geocoding Service (only works with singleLine)
    "countries": "sourceCountry"
  },
  initialize: function(options2) {
    options2 = options2 || {};
    options2.url = options2.url || WorldGeocodingServiceUrl;
    Task.prototype.initialize.call(this, options2);
  },
  within: function(bounds2) {
    bounds2 = (0, import_leaflet16.latLngBounds)(bounds2);
    this.params.searchExtent = EsriUtil.boundsToExtent(bounds2);
    return this;
  },
  nearby: function(coords, radius) {
    var centroid = (0, import_leaflet16.latLng)(coords);
    this.params.location = centroid.lng + "," + centroid.lat;
    this.params.distance = Math.min(Math.max(radius, 2e3), 5e4);
    return this;
  },
  run: function(callback, context) {
    if (this.options.customParam) {
      this.params[this.options.customParam] = this.params.singleLine;
      delete this.params.singleLine;
    }
    return this.request(function(error, response) {
      var processor = this._processGeocoderResponse;
      var results = !error ? processor(response) : void 0;
      callback.call(context, error, { results }, response);
    }, this);
  },
  _processGeocoderResponse: function(response) {
    var results = [];
    for (var i = 0; i < response.candidates.length; i++) {
      var candidate = response.candidates[i];
      if (candidate.extent) {
        var bounds2 = EsriUtil.extentToBounds(candidate.extent);
      }
      results.push({
        text: candidate.address,
        bounds: bounds2,
        score: candidate.score,
        latlng: (0, import_leaflet16.latLng)(candidate.location.y, candidate.location.x),
        properties: candidate.attributes
      });
    }
    return results;
  }
});
function geocode(options2) {
  return new Geocode(options2);
}
var Geocode_default = geocode;

// node_modules/esri-leaflet-geocoder/src/Tasks/ReverseGeocode.js
var import_leaflet17 = __toESM(require_leaflet_src());
var ReverseGeocode = Task.extend({
  path: "reverseGeocode",
  params: {
    outSR: 4326,
    returnIntersection: false
  },
  setters: {
    "distance": "distance",
    "language": "langCode",
    "intersection": "returnIntersection"
  },
  initialize: function(options2) {
    options2 = options2 || {};
    options2.url = options2.url || WorldGeocodingServiceUrl;
    Task.prototype.initialize.call(this, options2);
  },
  latlng: function(coords) {
    var centroid = (0, import_leaflet17.latLng)(coords);
    this.params.location = centroid.lng + "," + centroid.lat;
    return this;
  },
  run: function(callback, context) {
    return this.request(function(error, response) {
      var result;
      if (!error) {
        result = {
          latlng: (0, import_leaflet17.latLng)(response.location.y, response.location.x),
          address: response.address
        };
      } else {
        result = void 0;
      }
      callback.call(context, error, result, response);
    }, this);
  }
});
function reverseGeocode(options2) {
  return new ReverseGeocode(options2);
}
var ReverseGeocode_default = reverseGeocode;

// node_modules/esri-leaflet-geocoder/src/Tasks/Suggest.js
var import_leaflet18 = __toESM(require_leaflet_src());
var Suggest = Task.extend({
  path: "suggest",
  params: {},
  setters: {
    text: "text",
    category: "category",
    countries: "countryCode",
    maxSuggestions: "maxSuggestions"
  },
  initialize: function(options2) {
    options2 = options2 || {};
    if (!options2.url) {
      options2.url = WorldGeocodingServiceUrl;
      options2.supportsSuggest = true;
    }
    Task.prototype.initialize.call(this, options2);
  },
  within: function(bounds2) {
    bounds2 = (0, import_leaflet18.latLngBounds)(bounds2);
    bounds2 = bounds2.pad(0.5);
    var center = bounds2.getCenter();
    var ne = bounds2.getNorthWest();
    this.params.location = center.lng + "," + center.lat;
    this.params.distance = Math.min(Math.max(center.distanceTo(ne), 2e3), 5e4);
    this.params.searchExtent = EsriUtil.boundsToExtent(bounds2);
    return this;
  },
  nearby: function(coords, radius) {
    var centroid = (0, import_leaflet18.latLng)(coords);
    this.params.location = centroid.lng + "," + centroid.lat;
    this.params.distance = Math.min(Math.max(radius, 2e3), 5e4);
    return this;
  },
  run: function(callback, context) {
    if (this.options.supportsSuggest) {
      return this.request(function(error, response) {
        callback.call(context, error, response, response);
      }, this);
    } else {
      console.warn("this geocoding service does not support asking for suggestions");
    }
  }
});
function suggest(options2) {
  return new Suggest(options2);
}
var Suggest_default = suggest;

// node_modules/esri-leaflet-geocoder/src/Services/Geocode.js
var GeocodeService = Service.extend({
  initialize: function(options2) {
    options2 = options2 || {};
    if (options2.url) {
      Service.prototype.initialize.call(this, options2);
      this._confirmSuggestSupport();
    } else {
      options2.url = WorldGeocodingServiceUrl;
      options2.supportsSuggest = true;
      Service.prototype.initialize.call(this, options2);
    }
  },
  geocode: function() {
    return Geocode_default(this);
  },
  reverse: function() {
    return ReverseGeocode_default(this);
  },
  suggest: function() {
    return Suggest_default(this);
  },
  _confirmSuggestSupport: function() {
    this.metadata(function(error, response) {
      if (error) {
        return;
      }
      if (!response.capabilities) {
        this.options.supportsSuggest = false;
      } else if (response.capabilities.indexOf("Suggest") > -1) {
        this.options.supportsSuggest = true;
      } else {
        this.options.supportsSuggest = false;
      }
      this.options.customParam = response.singleLineAddressField.name;
    }, this);
  }
});
function geocodeService(options2) {
  return new GeocodeService(options2);
}

// node_modules/esri-leaflet-geocoder/src/Controls/Geosearch.js
var import_leaflet20 = __toESM(require_leaflet_src());

// node_modules/esri-leaflet-geocoder/src/Classes/GeosearchCore.js
var import_leaflet19 = __toESM(require_leaflet_src());
var GeosearchCore = import_leaflet19.Evented.extend({
  options: {
    zoomToResult: true,
    useMapBounds: 12,
    searchBounds: null
  },
  initialize: function(control, options2) {
    import_leaflet19.Util.setOptions(this, options2);
    this._control = control;
    if (!options2 || !options2.providers || !options2.providers.length) {
      throw new Error("You must specify at least one provider");
    }
    this._providers = options2.providers;
  },
  _geocode: function(text, key, provider) {
    var activeRequests = 0;
    var allResults = [];
    var bounds2;
    var callback = import_leaflet19.Util.bind(function(error, results) {
      activeRequests--;
      if (error) {
        return;
      }
      if (results) {
        allResults = allResults.concat(results);
      }
      if (activeRequests <= 0) {
        bounds2 = this._boundsFromResults(allResults);
        this.fire("results", {
          results: allResults,
          bounds: bounds2,
          latlng: bounds2 ? bounds2.getCenter() : void 0,
          text
        }, true);
        if (this.options.zoomToResult && bounds2) {
          this._control._map.fitBounds(bounds2);
        }
        this.fire("load");
      }
    }, this);
    if (key) {
      activeRequests++;
      provider.results(text, key, this._searchBounds(), callback);
    } else {
      for (var i = 0; i < this._providers.length; i++) {
        activeRequests++;
        this._providers[i].results(text, key, this._searchBounds(), callback);
      }
    }
  },
  _suggest: function(text) {
    var activeRequests = this._providers.length;
    var suggestionsLength = 0;
    var createCallback = import_leaflet19.Util.bind(function(text2, provider2) {
      return import_leaflet19.Util.bind(function(error, suggestions) {
        activeRequests = activeRequests - 1;
        suggestionsLength += suggestions.length;
        if (error) {
          this._control._clearProviderSuggestions(provider2);
          this._control._finalizeSuggestions(activeRequests, suggestionsLength);
          return;
        }
        if (suggestions.length) {
          for (var i2 = 0; i2 < suggestions.length; i2++) {
            suggestions[i2].provider = provider2;
          }
        } else {
          this._control._renderSuggestions(suggestions);
        }
        if (provider2._lastRender !== text2) {
          this._control._clearProviderSuggestions(provider2);
        }
        if (suggestions.length && this._control._input.value === text2) {
          provider2._lastRender = text2;
          this._control._renderSuggestions(suggestions);
        }
        this._control._finalizeSuggestions(activeRequests, suggestionsLength);
      }, this);
    }, this);
    this._pendingSuggestions = [];
    for (var i = 0; i < this._providers.length; i++) {
      var provider = this._providers[i];
      var request2 = provider.suggestions(text, this._searchBounds(), createCallback(text, provider));
      this._pendingSuggestions.push(request2);
    }
  },
  _searchBounds: function() {
    if (this.options.searchBounds !== null) {
      return this.options.searchBounds;
    }
    if (this.options.useMapBounds === false) {
      return null;
    }
    if (this.options.useMapBounds === true) {
      return this._control._map.getBounds();
    }
    if (this.options.useMapBounds <= this._control._map.getZoom()) {
      return this._control._map.getBounds();
    }
    return null;
  },
  _boundsFromResults: function(results) {
    if (!results.length) {
      return;
    }
    var nullIsland = (0, import_leaflet19.latLngBounds)([0, 0], [0, 0]);
    var resultBounds = [];
    var resultLatlngs = [];
    for (var i = results.length - 1; i >= 0; i--) {
      var result = results[i];
      resultLatlngs.push(result.latlng);
      if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {
        resultBounds.push(result.bounds);
      }
    }
    var bounds2 = (0, import_leaflet19.latLngBounds)(resultLatlngs);
    for (var j = 0; j < resultBounds.length; j++) {
      bounds2.extend(resultBounds[j]);
    }
    return bounds2;
  },
  _getAttribution: function() {
    var attribs = [];
    var providers = this._providers;
    for (var i = 0; i < providers.length; i++) {
      if (providers[i].options.attribution) {
        attribs.push(providers[i].options.attribution);
      }
    }
    return attribs.join(", ");
  }
});
function geosearchCore(control, options2) {
  return new GeosearchCore(control, options2);
}

// node_modules/esri-leaflet-geocoder/src/Providers/ArcgisOnlineGeocoder.js
var ArcgisOnlineProvider = GeocodeService.extend({
  options: {
    label: "Places and Addresses",
    maxResults: 5
  },
  suggestions: function(text, bounds2, callback) {
    var request2 = this.suggest().text(text);
    if (bounds2) {
      request2.within(bounds2);
    }
    if (this.options.countries) {
      request2.countries(this.options.countries);
    }
    if (this.options.categories) {
      request2.category(this.options.categories);
    }
    request2.maxSuggestions(this.options.maxResults);
    return request2.run(function(error, results, response) {
      var suggestions = [];
      if (!error) {
        while (response.suggestions.length && suggestions.length <= this.options.maxResults - 1) {
          var suggestion = response.suggestions.shift();
          if (!suggestion.isCollection) {
            suggestions.push({
              text: suggestion.text,
              unformattedText: suggestion.text,
              magicKey: suggestion.magicKey
            });
          }
        }
      }
      callback(error, suggestions);
    }, this);
  },
  results: function(text, key, bounds2, callback) {
    var request2 = this.geocode().text(text);
    if (key) {
      request2.key(key);
    }
    request2.maxLocations(this.options.maxResults);
    if (bounds2) {
      request2.within(bounds2);
    }
    if (this.options.forStorage) {
      request2.forStorage(true);
    }
    if (this.options.countries) {
      request2.countries(this.options.countries);
    }
    if (this.options.categories) {
      request2.category(this.options.categories);
    }
    return request2.run(function(error, response) {
      callback(error, response.results);
    }, this);
  }
});
function arcgisOnlineProvider(options2) {
  return new ArcgisOnlineProvider(options2);
}

// node_modules/esri-leaflet-geocoder/src/Controls/Geosearch.js
var Geosearch = import_leaflet20.Control.extend({
  includes: import_leaflet20.Evented.prototype,
  options: {
    position: "topleft",
    collapseAfterResult: true,
    expanded: false,
    allowMultipleResults: true,
    placeholder: "Search for places or addresses",
    title: "Location Search"
  },
  initialize: function(options2) {
    import_leaflet20.Util.setOptions(this, options2);
    if (!options2 || !options2.providers || !options2.providers.length) {
      if (!options2) {
        options2 = {};
      }
      options2.providers = [arcgisOnlineProvider()];
    }
    this._geosearchCore = geosearchCore(this, options2);
    this._geosearchCore._providers = options2.providers;
    this._geosearchCore.addEventParent(this);
    for (var i = 0; i < this._geosearchCore._providers.length; i++) {
      this._geosearchCore._providers[i].addEventParent(this);
    }
    this._geosearchCore._pendingSuggestions = [];
    import_leaflet20.Control.prototype.initialize.call(this, options2);
  },
  _renderSuggestions: function(suggestions) {
    var currentGroup;
    if (suggestions.length > 0) {
      this._suggestions.style.display = "block";
    }
    var list;
    var header;
    var suggestionTextArray = [];
    for (var i = 0; i < suggestions.length; i++) {
      var suggestion = suggestions[i];
      if (!header && this._geosearchCore._providers.length > 1 && currentGroup !== suggestion.provider.options.label) {
        header = import_leaflet20.DomUtil.create("div", "geocoder-control-header", suggestion.provider._contentsElement);
        header.textContent = suggestion.provider.options.label;
        header.innerText = suggestion.provider.options.label;
        currentGroup = suggestion.provider.options.label;
      }
      if (!list) {
        list = import_leaflet20.DomUtil.create("ul", "geocoder-control-list", suggestion.provider._contentsElement);
      }
      if (suggestionTextArray.indexOf(suggestion.text) === -1) {
        var suggestionItem = import_leaflet20.DomUtil.create("li", "geocoder-control-suggestion", list);
        suggestionItem.innerHTML = suggestion.text;
        suggestionItem.provider = suggestion.provider;
        suggestionItem["data-magic-key"] = suggestion.magicKey;
        suggestionItem.unformattedText = suggestion.unformattedText;
      } else {
        for (var j = 0; j < list.childNodes.length; j++) {
          if (list.childNodes[j].innerHTML === suggestion.text) {
            list.childNodes[j]["data-magic-key"] += "," + suggestion.magicKey;
          }
        }
      }
      suggestionTextArray.push(suggestion.text);
    }
    if (this.getPosition().indexOf("top") > -1) {
      this._suggestions.style.maxHeight = this._map.getSize().y - this._suggestions.offsetTop - this._wrapper.offsetTop - 10 + "px";
    }
    if (this.getPosition().indexOf("bottom") > -1) {
      this._setSuggestionsBottomPosition();
    }
  },
  _setSuggestionsBottomPosition: function() {
    this._suggestions.style.maxHeight = this._map.getSize().y - this._map._controlCorners[this.getPosition()].offsetHeight - this._wrapper.offsetHeight + "px";
    this._suggestions.style.top = -this._suggestions.offsetHeight - this._wrapper.offsetHeight + 20 + "px";
  },
  _boundsFromResults: function(results) {
    if (!results.length) {
      return;
    }
    var nullIsland = (0, import_leaflet20.latLngBounds)([0, 0], [0, 0]);
    var resultBounds = [];
    var resultLatlngs = [];
    for (var i = results.length - 1; i >= 0; i--) {
      var result = results[i];
      resultLatlngs.push(result.latlng);
      if (result.bounds && result.bounds.isValid() && !result.bounds.equals(nullIsland)) {
        resultBounds.push(result.bounds);
      }
    }
    var bounds2 = (0, import_leaflet20.latLngBounds)(resultLatlngs);
    for (var j = 0; j < resultBounds.length; j++) {
      bounds2.extend(resultBounds[j]);
    }
    return bounds2;
  },
  clear: function() {
    this._clearAllSuggestions();
    if (this.options.collapseAfterResult) {
      this._input.value = "";
      this._lastValue = "";
      this._input.placeholder = "";
      import_leaflet20.DomUtil.removeClass(this._wrapper, "geocoder-control-expanded");
    }
    if (!this._map.scrollWheelZoom.enabled() && this._map.options.scrollWheelZoom) {
      this._map.scrollWheelZoom.enable();
    }
  },
  _clearAllSuggestions: function() {
    this._suggestions.style.display = "none";
    for (var i = 0; i < this.options.providers.length; i++) {
      this._clearProviderSuggestions(this.options.providers[i]);
    }
  },
  _clearProviderSuggestions: function(provider) {
    provider._contentsElement.innerHTML = "";
  },
  _finalizeSuggestions: function(activeRequests, suggestionsLength) {
    if (!activeRequests) {
      import_leaflet20.DomUtil.removeClass(this._input, "geocoder-control-loading");
      if (this.getPosition().indexOf("bottom") > -1) {
        this._setSuggestionsBottomPosition();
      }
      if (!suggestionsLength) {
        this._clearAllSuggestions();
      }
    }
  },
  _setupClick: function() {
    import_leaflet20.DomUtil.addClass(this._wrapper, "geocoder-control-expanded");
    this._input.focus();
  },
  disable: function() {
    this._input.disabled = true;
    import_leaflet20.DomUtil.addClass(this._input, "geocoder-control-input-disabled");
    import_leaflet20.DomEvent.removeListener(this._wrapper, "click", this._setupClick, this);
  },
  enable: function() {
    this._input.disabled = false;
    import_leaflet20.DomUtil.removeClass(this._input, "geocoder-control-input-disabled");
    import_leaflet20.DomEvent.addListener(this._wrapper, "click", this._setupClick, this);
  },
  getAttribution: function() {
    var attribs = [];
    for (var i = 0; i < this._providers.length; i++) {
      if (this._providers[i].options.attribution) {
        attribs.push(this._providers[i].options.attribution);
      }
    }
    return attribs.join(", ");
  },
  geocodeSuggestion: function(e) {
    var suggestionItem = e.target || e.srcElement;
    if (suggestionItem.classList.contains("geocoder-control-suggestions") || suggestionItem.classList.contains("geocoder-control-header")) {
      return;
    }
    if (suggestionItem.classList.length < 1) {
      suggestionItem = suggestionItem.parentNode;
    }
    this._geosearchCore._geocode(suggestionItem.unformattedText, suggestionItem["data-magic-key"], suggestionItem.provider);
    this.clear();
  },
  onAdd: function(map) {
    EsriUtil.setEsriAttribution(map);
    this._map = map;
    this._wrapper = import_leaflet20.DomUtil.create("div", "geocoder-control");
    this._input = import_leaflet20.DomUtil.create("input", "geocoder-control-input leaflet-bar", this._wrapper);
    this._input.title = this.options.title;
    if (this.options.expanded) {
      import_leaflet20.DomUtil.addClass(this._wrapper, "geocoder-control-expanded");
      this._input.placeholder = this.options.placeholder;
    }
    this._suggestions = import_leaflet20.DomUtil.create("div", "geocoder-control-suggestions leaflet-bar", this._wrapper);
    for (var i = 0; i < this.options.providers.length; i++) {
      this.options.providers[i]._contentsElement = import_leaflet20.DomUtil.create("div", null, this._suggestions);
    }
    var credits = this._geosearchCore._getAttribution();
    if (map.attributionControl) {
      map.attributionControl.addAttribution(credits);
    }
    import_leaflet20.DomEvent.addListener(this._input, "focus", function(e) {
      this._input.placeholder = this.options.placeholder;
      import_leaflet20.DomUtil.addClass(this._wrapper, "geocoder-control-expanded");
    }, this);
    import_leaflet20.DomEvent.addListener(this._wrapper, "click", this._setupClick, this);
    import_leaflet20.DomEvent.addListener(this._suggestions, "mousedown", this.geocodeSuggestion, this);
    import_leaflet20.DomEvent.addListener(this._input, "blur", function(e) {
      this.clear();
    }, this);
    import_leaflet20.DomEvent.addListener(this._input, "keydown", function(e) {
      var text = (e.target || e.srcElement).value;
      import_leaflet20.DomUtil.addClass(this._wrapper, "geocoder-control-expanded");
      var list = this._suggestions.querySelectorAll(".geocoder-control-suggestion");
      var selected = this._suggestions.querySelectorAll(".geocoder-control-selected")[0];
      var selectedPosition;
      for (var i2 = 0; i2 < list.length; i2++) {
        if (list[i2] === selected) {
          selectedPosition = i2;
          break;
        }
      }
      switch (e.keyCode) {
        case 13:
          if (selected) {
            this._input.value = selected.innerText;
            this._geosearchCore._geocode(selected.unformattedText, selected["data-magic-key"], selected.provider);
            this.clear();
          } else if (this.options.allowMultipleResults && text.length >= 2) {
            this._geosearchCore._geocode(this._input.value, void 0);
            this.clear();
          } else {
            if (list.length === 1) {
              import_leaflet20.DomUtil.addClass(list[0], "geocoder-control-selected");
              this._geosearchCore._geocode(list[0].innerHTML, list[0]["data-magic-key"], list[0].provider);
            } else {
              this.clear();
              this._input.blur();
            }
          }
          import_leaflet20.DomEvent.preventDefault(e);
          break;
        case 38:
          if (selected) {
            import_leaflet20.DomUtil.removeClass(selected, "geocoder-control-selected");
          }
          var previousItem = list[selectedPosition - 1];
          if (selected && previousItem) {
            import_leaflet20.DomUtil.addClass(previousItem, "geocoder-control-selected");
          } else {
            import_leaflet20.DomUtil.addClass(list[list.length - 1], "geocoder-control-selected");
          }
          import_leaflet20.DomEvent.preventDefault(e);
          break;
        case 40:
          if (selected) {
            import_leaflet20.DomUtil.removeClass(selected, "geocoder-control-selected");
          }
          var nextItem = list[selectedPosition + 1];
          if (selected && nextItem) {
            import_leaflet20.DomUtil.addClass(nextItem, "geocoder-control-selected");
          } else {
            import_leaflet20.DomUtil.addClass(list[0], "geocoder-control-selected");
          }
          import_leaflet20.DomEvent.preventDefault(e);
          break;
        default:
          for (var x = 0; x < this._geosearchCore._pendingSuggestions.length; x++) {
            var request2 = this._geosearchCore._pendingSuggestions[x];
            if (request2 && request2.abort && !request2.id) {
              request2.abort();
            }
          }
          break;
      }
    }, this);
    import_leaflet20.DomEvent.addListener(this._input, "keyup", import_leaflet20.Util.throttle(function(e) {
      var key = e.which || e.keyCode;
      var text = (e.target || e.srcElement).value;
      if (text.length < 2) {
        this._lastValue = this._input.value;
        this._clearAllSuggestions();
        import_leaflet20.DomUtil.removeClass(this._input, "geocoder-control-loading");
        return;
      }
      if (key === 27) {
        this._clearAllSuggestions();
        return;
      }
      if (key !== 13 && key !== 38 && key !== 40) {
        if (this._input.value !== this._lastValue) {
          this._lastValue = this._input.value;
          import_leaflet20.DomUtil.addClass(this._input, "geocoder-control-loading");
          this._geosearchCore._suggest(text);
        }
      }
    }, 50, this), this);
    import_leaflet20.DomEvent.disableClickPropagation(this._wrapper);
    import_leaflet20.DomEvent.addListener(this._suggestions, "mouseover", function(e) {
      if (map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {
        map.scrollWheelZoom.disable();
      }
    });
    import_leaflet20.DomEvent.addListener(this._suggestions, "mouseout", function(e) {
      if (!map.scrollWheelZoom.enabled() && map.options.scrollWheelZoom) {
        map.scrollWheelZoom.enable();
      }
    });
    this._geosearchCore.on("load", function(e) {
      import_leaflet20.DomUtil.removeClass(this._input, "geocoder-control-loading");
      this.clear();
      this._input.blur();
    }, this);
    return this._wrapper;
  }
});
function geosearch(options2) {
  return new Geosearch(options2);
}

// node_modules/esri-leaflet-geocoder/src/Providers/FeatureLayer.js
var import_leaflet21 = __toESM(require_leaflet_src());
var FeatureLayerProvider = FeatureLayerService.extend({
  options: {
    label: "Feature Layer",
    maxResults: 5,
    bufferRadius: 1e3,
    searchMode: "contain",
    formatSuggestion: function(feature) {
      return feature.properties[this.options.searchFields[0]];
    }
  },
  initialize: function(options2) {
    FeatureLayerService.prototype.initialize.call(this, options2);
    if (typeof this.options.searchFields === "string") {
      this.options.searchFields = [this.options.searchFields];
    }
    this._suggestionsQuery = this.query();
    this._resultsQuery = this.query();
  },
  suggestions: function(text, bounds2, callback) {
    var query2 = this._suggestionsQuery.where(this._buildQuery(text)).returnGeometry(false);
    if (bounds2) {
      query2.intersects(bounds2);
    }
    if (this.options.idField) {
      query2.fields([this.options.idField].concat(this.options.searchFields));
    }
    var request2 = query2.run(function(error, results, raw) {
      if (error) {
        callback(error, []);
      } else {
        this.options.idField = raw.objectIdFieldName;
        var suggestions = [];
        for (var i = results.features.length - 1; i >= 0; i--) {
          var feature = results.features[i];
          suggestions.push({
            text: this.options.formatSuggestion.call(this, feature),
            unformattedText: feature.properties[this.options.searchFields[0]],
            magicKey: feature.id
          });
        }
        callback(error, suggestions.slice(0, this.options.maxResults));
      }
    }, this);
    return request2;
  },
  results: function(text, key, bounds2, callback) {
    var query2 = this._resultsQuery;
    if (key) {
      delete query2.params.where;
      query2.featureIds([key]);
    } else {
      query2.where(this._buildQuery(text));
    }
    if (bounds2) {
      query2.within(bounds2);
    }
    return query2.run(import_leaflet21.Util.bind(function(error, features) {
      var results = [];
      for (var i = 0; i < features.features.length; i++) {
        var feature = features.features[i];
        if (feature) {
          var bounds3 = this._featureBounds(feature);
          var result = {
            latlng: bounds3.getCenter(),
            bounds: bounds3,
            text: this.options.formatSuggestion.call(this, feature),
            properties: feature.properties,
            geojson: feature
          };
          results.push(result);
          delete this._resultsQuery.params["objectIds"];
        }
      }
      callback(error, results);
    }, this));
  },
  orderBy: function(fieldName, order) {
    this._suggestionsQuery.orderBy(fieldName, order);
  },
  _buildQuery: function(text) {
    var queryString = [];
    for (var i = this.options.searchFields.length - 1; i >= 0; i--) {
      var field = 'upper("' + this.options.searchFields[i] + '")';
      if (this.options.searchMode === "contain") {
        queryString.push(field + " LIKE upper('%" + text + "%')");
      } else if (this.options.searchMode === "startWith") {
        queryString.push(field + " LIKE upper('" + text + "%')");
      } else if (this.options.searchMode === "endWith") {
        queryString.push(field + " LIKE upper('%" + text + "')");
      } else if (this.options.searchMode === "strict") {
        queryString.push(field + " LIKE upper('" + text + "')");
      } else {
        throw new Error('L.esri.Geocoding.featureLayerProvider: Invalid parameter for "searchMode". Use one of "contain", "startWith", "endWith", or "strict"');
      }
    }
    if (this.options.where) {
      return this.options.where + " AND (" + queryString.join(" OR ") + ")";
    } else {
      return queryString.join(" OR ");
    }
  },
  _featureBounds: function(feature) {
    var geojson = (0, import_leaflet21.geoJson)(feature);
    if (feature.geometry.type === "Point") {
      var center = geojson.getBounds().getCenter();
      var lngRadius = this.options.bufferRadius / 40075017 * 360 / Math.cos(180 / Math.PI * center.lat);
      var latRadius = this.options.bufferRadius / 40075017 * 360;
      return (0, import_leaflet21.latLngBounds)([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);
    } else {
      return geojson.getBounds();
    }
  }
});
function featureLayerProvider(options2) {
  return new FeatureLayerProvider(options2);
}

// node_modules/esri-leaflet-geocoder/src/Providers/MapService.js
var import_leaflet22 = __toESM(require_leaflet_src());
var MapServiceProvider = MapService.extend({
  options: {
    layers: [0],
    label: "Map Service",
    bufferRadius: 1e3,
    maxResults: 5,
    formatSuggestion: function(feature) {
      return feature.properties[feature.displayFieldName] + " <small>" + feature.layerName + "</small>";
    }
  },
  initialize: function(options2) {
    MapService.prototype.initialize.call(this, options2);
    this._getIdFields();
  },
  suggestions: function(text, bounds2, callback) {
    var request2 = this.find().text(text).fields(this.options.searchFields).returnGeometry(false).layers(this.options.layers);
    return request2.run(function(error, results, raw) {
      var suggestions = [];
      if (!error) {
        var count = Math.min(this.options.maxResults, results.features.length);
        raw.results = raw.results.reverse();
        for (var i = 0; i < count; i++) {
          var feature = results.features[i];
          var result = raw.results[i];
          var layer = result.layerId;
          var idField = this._idFields[layer];
          feature.layerId = layer;
          feature.layerName = this._layerNames[layer];
          feature.displayFieldName = this._displayFields[layer];
          if (idField) {
            suggestions.push({
              text: this.options.formatSuggestion.call(this, feature),
              unformattedText: feature.properties[feature.displayFieldName],
              magicKey: result.attributes[idField] + ":" + layer
            });
          }
        }
      }
      callback(error, suggestions.reverse());
    }, this);
  },
  results: function(text, key, bounds2, callback) {
    var results = [];
    var request2;
    if (key) {
      var featureId = key.split(":")[0];
      var layer = key.split(":")[1];
      request2 = this.query().layer(layer).featureIds(featureId);
    } else {
      request2 = this.find().text(text).fields(this.options.searchFields).layers(this.options.layers);
    }
    return request2.run(function(error, features, response) {
      if (!error) {
        if (response.results) {
          response.results = response.results.reverse();
        }
        for (var i = 0; i < features.features.length; i++) {
          var feature = features.features[i];
          layer = layer || response.results[i].layerId;
          if (feature && layer !== void 0) {
            var bounds3 = this._featureBounds(feature);
            feature.layerId = layer;
            feature.layerName = this._layerNames[layer];
            feature.displayFieldName = this._displayFields[layer];
            var result = {
              latlng: bounds3.getCenter(),
              bounds: bounds3,
              text: this.options.formatSuggestion.call(this, feature),
              properties: feature.properties,
              geojson: feature
            };
            results.push(result);
          }
        }
      }
      callback(error, results.reverse());
    }, this);
  },
  _featureBounds: function(feature) {
    var geojson = (0, import_leaflet22.geoJson)(feature);
    if (feature.geometry.type === "Point") {
      var center = geojson.getBounds().getCenter();
      var lngRadius = this.options.bufferRadius / 40075017 * 360 / Math.cos(180 / Math.PI * center.lat);
      var latRadius = this.options.bufferRadius / 40075017 * 360;
      return (0, import_leaflet22.latLngBounds)([center.lat - latRadius, center.lng - lngRadius], [center.lat + latRadius, center.lng + lngRadius]);
    } else {
      return geojson.getBounds();
    }
  },
  _layerMetadataCallback: function(layerid) {
    return import_leaflet22.Util.bind(function(error, metadata) {
      if (error) {
        return;
      }
      this._displayFields[layerid] = metadata.displayField;
      this._layerNames[layerid] = metadata.name;
      for (var i = 0; i < metadata.fields.length; i++) {
        var field = metadata.fields[i];
        if (field.type === "esriFieldTypeOID") {
          this._idFields[layerid] = field.name;
          break;
        }
      }
    }, this);
  },
  _getIdFields: function() {
    this._idFields = {};
    this._displayFields = {};
    this._layerNames = {};
    for (var i = 0; i < this.options.layers.length; i++) {
      var layer = this.options.layers[i];
      this.get(layer, {}, this._layerMetadataCallback(layer));
    }
  }
});
function mapServiceProvider(options2) {
  return new MapServiceProvider(options2);
}

// node_modules/esri-leaflet-geocoder/src/Providers/GeocodeService.js
var GeocodeServiceProvider = GeocodeService.extend({
  options: {
    label: "Geocode Server",
    maxResults: 5
  },
  suggestions: function(text, bounds2, callback) {
    if (this.options.supportsSuggest) {
      var request2 = this.suggest().text(text);
      if (bounds2) {
        request2.within(bounds2);
      }
      return request2.run(function(error, results, response) {
        var suggestions = [];
        if (!error) {
          while (response.suggestions.length && suggestions.length <= this.options.maxResults - 1) {
            var suggestion = response.suggestions.shift();
            if (!suggestion.isCollection) {
              suggestions.push({
                text: suggestion.text,
                unformattedText: suggestion.text,
                magicKey: suggestion.magicKey
              });
            }
          }
        }
        callback(error, suggestions);
      }, this);
    } else {
      callback(void 0, []);
      return false;
    }
  },
  results: function(text, key, bounds2, callback) {
    var request2 = this.geocode().text(text);
    if (key) {
      request2.key(key);
    }
    request2.maxLocations(this.options.maxResults);
    if (bounds2) {
      request2.within(bounds2);
    }
    return request2.run(function(error, response) {
      callback(error, response.results);
    }, this);
  }
});
function geocodeServiceProvider(options2) {
  return new GeocodeServiceProvider(options2);
}
export {
  ArcgisOnlineProvider,
  FeatureLayerProvider,
  Geocode,
  GeocodeService,
  GeocodeServiceProvider,
  Geosearch,
  GeosearchCore,
  MapServiceProvider,
  ReverseGeocode,
  Suggest,
  version as VERSION,
  WorldGeocodingServiceUrl,
  arcgisOnlineProvider,
  featureLayerProvider,
  geocode,
  geocodeService,
  geocodeServiceProvider,
  geosearch,
  geosearchCore,
  mapServiceProvider,
  reverseGeocode,
  suggest
};
/*! Bundled license information:

@terraformer/arcgis/dist/t-arcgis.esm.js:
  (* @preserve
  * @terraformer/arcgis - v2.1.1 - MIT
  * Copyright (c) 2012-2022 Environmental Systems Research Institute, Inc.
  * Tue Aug 02 2022 14:23:48 GMT-0700 (Pacific Daylight Time)
  *)
*/
//# sourceMappingURL=esri-leaflet-geocoder.js.map
